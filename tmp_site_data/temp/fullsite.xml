<site  xmlns:xhtml="http://www.w3.org/1999/xhtml" xmlns:xi="http://www.w3.org/2001/XInclude" xmlns:xf="http://www.w3.org/2002/xforms">
  <siteurl >www.tony.gen.nz/xml</siteurl>
  <html_dir >html</html_dir>
  <resources >
    <copydir >html</copydir>
  </resources>
  <file_headers >&lt;?xml version=&quot;1.0&quot;?&gt;&lt;!DOCTYPE html&gt;</file_headers>
  <pages >
    <homepage >index.xhtml</homepage>
    <navtype >mesh</navtype>
    <contact-phone >Phone: 027 2203796</contact-phone>
    <contact-email ><xhtml:a  href="mailto:tony@tony.gen.nz">Email: tony@tony.gen.nz</xhtml:a></contact-email>
    <banner_image ><xhtml:img  width="100%" left="250px" src="images/hw.png"></xhtml:img></banner_image>
    <page  xmlns:ax="abc">
  <name >Main</name>
  <title >Main</title>
  <url >index.xhtml</url>
  <keywords >xml</keywords>
  <pageheader >Greenrose</pageheader>
<ax:content  xmlns:xh="http://www.w3.org/1999/xhtml">
<h1 >Tony&apos;s Main Page</h1>
<p >This website is currently documenting procedures
for making itself and keeping itself updated.  At
the moment this is limited to static sites but as
extra facilities are added these too will be documented
here. </p>
<ol >
<li ><a  href="intro.xhtml">Generating a wesite with XSLT</a></li>
<li ><a  href="addwebsite.xhtml">Admin guide</a></li>
</ol>

</ax:content>
</page>
  </pages>
  <pages >
    <homepage >index.xhtml</homepage>
    <navtype >mesh</navtype>
    <contact-phone >Phone: 027 2203796</contact-phone>
    <contact-email ><xhtml:a  href="mailto:tony@tony.gen.nz">Email: tony@tony.gen.nz</xhtml:a></contact-email>
    <banner_image ><xhtml:img  width="100%" left="250px" src="images/hw.png"></xhtml:img></banner_image>
    <page  xmlns:ax="abc">
  <name >intro</name>
  <title >XML Sojourner&apos;s Journey</title>
  <url >intro.xhtml</url>
  <keywords >xml</keywords>
  <pageheader >Greenrose</pageheader>
<ax:content  xmlns:xh="http://www.w3.org/1999/xhtml">
<xh:p >This is the introduction page to my xml diary.  It is not
a diary in the sense of a chronology.  It is not a book in
that it will never be complete.  It is not a blog as I ask
no feedback, look for none and expect none.</xh:p>
<xh:p >Rather it documents my journeys in XML land.  One of
the frontiers of the web.  Many have gone before me and
blazed the trail, but alas it is a confusing place for
newcommers, and I hope that this work, incomplete (and
possibly in places inaccurate) may help the sojourners
who wander this trail after me.</xh:p>
<xh:p >The question remains as to why would someone choose
this journey?</xh:p>
<xh:ul >
  <xh:li ><xh:em >XML is standard.</xh:em> It is a language understood
throughout the computing world.</xh:li>
<xh:li ><xh:em >XML is expressive.</xh:em> XML naturally expresses complex
data structures and is useful for a huge number of applications
from word processors to graphics editiors.</xh:li>
<xh:li ><xh:em >Standard XML tools</xh:em> allow complex analysis of the
data contained in XML files, and the transformation of XML
data between formats</xh:li>
<xh:li ><xh:em >Communication.</xh:em> XML is used to communicate data
between systems for e-commerce.</xh:li>
<xh:li ><xh:em >XRX </xh:em>XML can facilitate the storage of data without
transforming it to another form as is usual in relation database
applications.</xh:li>
</xh:ul>

<xh:p >Yes there is gold in this land, but it comes not easily.
In my wanderings I have frequently found if I did not
understand a concept futher progress in a different area
became impossible, and that there is an order in which
topics are to be followed, so this journey is a trail
and the reader is advised to follow the track in order
to not get lost.</xh:p>
<xh:p >Consequently there is no attempt in this work to deal
with any of these technologies in a comprehensive manner.
That work has been done by others.  Rather it is an attempt
to guide through these technologies in a systematic way.
</xh:p>
<xh:p >Indeed my journey has been guided by a vision, the same
vision that prompted Dan Cleary and others with XRX.  To
move away from the continual construction and deconstruction
of data structures as usual with application development.
To utilise the Web as the main interface.  To use standard
tools  that are free.  To keep related data together rather than normalised
into separate tables. To build systems that are maintainable,
scalable, and parallel processor friendly.</xh:p>
<xh:p >This quest is far from over, but I gladly share my wanderings.</xh:p>
</ax:content>
</page>
    <page  xmlns:ax="abc">
  <name >whatsxml</name>
  <title >What is XML</title>
  <url >whatsxml.html</url>
  <keywords >xml</keywords>
  <pageheader >Greenrose</pageheader>
  <file_headers >&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.0 Transactional//EN&quot;
&quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd&quot;&gt;</file_headers>
  <todo >Find url for XML 1.0.  Get a copy for my computer also</todo>
  <todo >Check the nomenculture for tags in XML standard and
adjust text accordingly</todo>
<content >
<p >XML which is an abbreviation of eXtensible markup language,
is a <a  href="need to put url here">standard</a> for formatting data.</p>
<p >An XML file has the following structure:</p>
<ol >
<li >An XML header</li>
<li >An optional list of processing instructions</li>
<li >A single root element holding all data</li>
</ol>
<p >The XML header item is recommended, not required by the standard.  
Processing instructions
can be used to great effect on occasion.  Elements contain an attribute
list and child elements.  The format is simple and widely understood,
this simple structure does however have its shortcomings.</p>
<ul >
  <li >Despite XML being tree structured, the headers and processing instructions prevent XML subtrees being merged to form larger trees in a simple fashion.</li>
  <li >As an XML document has a single root, data cannot be appended by simply appending to the end of the file.  The new data must instead be included within the root element and the entire tree rewritten.</li></ul>
<h2 >Example1: An XML file</h2>
<p >This example shows most features of xml, including:</p>
<ul >
<li >an xml declaration</li>
<li >a comment</li>
<li >a root element containing an attribute/value pair</li>
<li >a nested element</li>
</ul>
<p >
Copy the following xml into a file with and open the file in your web browser:</p>
<pre >

&lt;?xml version=1.0?&gt;
&lt;!-- This is a comment --&gt; 
&lt;root attribute=&quot;attributevalue&quot;&gt;
   This text is in the root element
   &lt;tag-with-close/&gt;
&lt;/root&gt;

</pre>

<h2 >Example2: XML with repeating structures</h2>
<p >When storing an invoice in a relational database
repeating structures such as line items are normalised
into a separate table.  XML allows related data to be
stored together.</p>
<pre >

&lt;?xml version=1.0?&gt;
&lt;invoice&gt;
  &lt;invnum&gt;3021&lt;/invnum&gt;
  &lt;invdate&gt;2015-03-22&lt;/invdate&gt;
  &lt;customer&gt;123&lt;/customer&gt;
  &lt;total&gt;5.01&lt;/total&gt;
  &lt;items&gt;
    &lt;item&gt;&lt;id&gt;1021&lt;/id&gt;&lt;name&gt;widget&lt;/name&gt;&lt;qty&gt;2&lt;/qty&gt;&lt;price&gt;1.00&lt;/price&gt;&lt;linetot&gt;2.00&lt;/linetot&gt;
    &lt;item&gt;&lt;id&gt;1&lt;/id&gt;&lt;name&gt;unl91&lt;/name&gt;&lt;qty&gt;3.02&lt;/qty&gt;&lt;price&gt;0.999&lt;/price&gt;&lt;linetot&gt;3.01&lt;/linetot&gt;
  &lt;/items&gt;
&lt;/invoice&gt;

</pre>

<h2 >Example3: Nested XML structure</h2>
<p >Some problems are naturally tree structured.  In this case
web pages can contain web pages.  The nesting of the xml
relecting the nesting of the pages.</p>
<pre >

&lt;?xml version=1.0?&gt;
&lt;site&gt;
  &lt;url&gt;www.mysite.com&lt;/url&gt;
  &lt;pages&gt;
    &lt;page&gt;
      &lt;url&gt;index.html&lt;/url&gt;
    &lt;/page&gt;
    &lt;page&gt;
      &lt;url&gt;contact.html&lt;/url&gt;
    &lt;/page&gt;
    &lt;page&gt;
      &lt;url&gt;content.html&lt;/url&gt;
      &lt;pages&gt;
	&lt;page&gt;
	  &lt;url&gt;products.html&lt;/url&gt;
	&lt;/page&gt;
	&lt;page&gt;
	  &lt;url&gt;shop.html&lt;/url&gt;
	&lt;/page&gt;
      &lt;/pages&gt;
    &lt;/page&gt;
  &lt;/pages&gt;
  &lt;pages&gt;
    &lt;page&gt;
      &lt;url&gt;admin.html&lt;/url&gt;
    &lt;/page&gt;
  &lt;/pages&gt;
&lt;/site&gt;

</pre>

</content>
</page>
    <page >
  <name >Xml processing</name>
  <title >xml processing</title>
  <url >xmlproc.html</url>
  <keywords >xml</keywords>
  <pageheader >Greenrose</pageheader>
  <file_headers >&lt;!DOCTYPE html&gt;</file_headers>
<content >
<p >XML processors of which there are three common types, SAX, DOM, XSLT
tokenise an XML document and these tokens are processed by the user application, not the raw text file.</p>
<p >SAX and DOM are libraries that make the content of the XML document
available to a host language such as Java.  DOM is used in conjuction
with JavaScript in AJAX web pages.  XSLT is an XML based language for
processing XML documents.</p>
<p >The API&apos;s for each language are different and independent, but they
exhibit strong simiarities.  XSLT is an important part of many XML tool
chains.  It can be used to convert a document (eg docbook) to pdf through
XSLT-FO.  XSLT delegates the interrogation of the XML document to the
XPATH language.</p>
<p >XPATH is also used as an XML interrogation language by XQUERY. XPATH expressions operate on a tree of nodes.  DOM offers such a tree.  An XPATH processor may operate on a DOM tree, or any other representation it chooses.  Proficiency with both XSLT and XQUERY requires a sound proficiency in XPATH.  The node types of an xml document (as defined by XPATH) are:
<ul >

<li >
<p >root nodes</p>
</li>

<li >
<p >element nodes</p>
</li>

<li >
<p >text nodes</p>
</li>

<li >
<p >attribute nodes</p>
</li>

<li >
<p >namespace nodes</p>
</li>

<li >
<p >processing instruction nodes</p>
</li>

<li >
<p >comment nodes</p>
</li>

</ul>

</p>
</content>
</page>
    <page >
  <name >namespaces</name>
  <title >Namespaces</title>
  <url >namespaces.html</url>
  <keywords >xml</keywords>
  <pageheader >Greenrose</pageheader>
  <file_headers >&lt;!DOCTYPE html&gt;</file_headers>
<content >
<p >This, the third stop in our sojourn in XML is about name spaces.
Up until now we have been inventing tagnames that suit us without
regard to what other are doing.  In order to share data around the
web everyone needs to be able to make their names unique, and this
is the purpose of namespaces.</p>
<p >In XML we leaverage off the uniqueness of URI identifiers to
form a scheme where XML authors can be confident of the uniqueness
of the names they use.  These unique names are called expanded names.</p>
<p >The abstract for the XML Namespaces standard succintly puts it: &quot;XML namespaces provide a simple method for qualifying element and attribute names used in Extensible Markup Language documents by associating them with namespaces identified by IRI references.&quot;</p>
<p >These namespaces are defined by xmlns attributes and attributes from the xmlns namespace.  For example:

&lt;root xmlns:xf=&quot;http://www.w3.org/2002/xforms&quot;
associates all tag and attributes starting with &quot;xf:&quot; to the xforms namespace.
This marks such tags and attributes as being part of the xforms.  An xforms
model element is thus specified as:

&lt;xf:model&gt;
</p>
<p >These namespaces allow different xml languages with different semantics
to be freely mixed in a single document.  To use xforms still requires an xforms processor to be installed on your system.</p>
<p >The name xf:model is an example of a <em >qualified name</em>.  A unique identifier is generated by expanding the prefix (in this case &quot;xf&quot;) by its associated string (in this case &quot;http://www.w3.org/2002/xforms&quot;.  The resulting name is called an <em >expanded name</em>.</p>
<p >This namespace mechanism allows xml tools to be extended in a modular fashion.</p>
</content>
</page>
    <page >
  <name >xpath</name>
  <title >xpath</title>
  <url >xpath.html</url>
  <keywords >xml</keywords>
  <pageheader >Greenrose</pageheader>
  <file_headers >&lt;!DOCTYPE html&gt;</file_headers>
<content >
<h2 >Introduction</h2>
<p >
At the last page Xml namespaces were introduced as a way of incorporating
various xml vocabularies into our documents.  It is time to meet the first
of these vocabularies, xpath, a tool for navigating through xml documents.</p>
<h2 >What is XPATH?</h2>
<p ><em >Xpath is a language for finding related nodes in an xml document.</em></p>
<p >Xml documents are read into software, and the various parts of the language
are parsed into nodes.</p>
<h3 >Xpath Nodes</h3>
<ul >
<li >elements</li>
<li >attributes</li>
<li >comments</li>
<li >whitespace</li>
<li >processing instructions</li>
<li >text</li>
</ul> 
<p >The relationships between
these nodes are stored in a structure known as an xml infoset. XPATH is a language for navigating 
an xml infoset.</p>
<p >XPATH is therefore an xml query language and is itself part of other XML languages
such as XSLT, XQUERY an XPOINTER.  Proficiency with XPATH is therefore a prerequisite
for proficiency in these other languages.</p>
<h2 >XPATH axes</h2>
<p >To understand xpath it is necessary to have in mind two models of the xml document at the same time:
<ul >
<li >Xml document as a tree</li>
<li >Xml document as a list</li>
</ul></p>
<p >
If you take any xml document and print it out, and a set of coloured highlighters.  Select a node and call it the current node colour it yellow.  This is the <em >self</em> axis.  Firstly considering the document as a tree, this node will have a parent node, which will in turn have a parent node up until the root node is reached.  Colour each of these pink. In xpath, this is the <em >ancestor</em> axis.  The current node may have children.  Colour these, and their decendents blue, this is the <em >decendent axis</em>.  The uncoloured nodes that are above the current document constitute the <em >preceeding axis</em>, and those uncoloured nodes following the current node are the <em >following axis</em>.  Finally those other nodes with the same parent which are preceeding the current node are <em >preceeding-sibling axis</em>.  The other nodes with the same parent but going down the page are the <em >following-sibling axis</em>.</p>
<p >There are other axes defined in the standard, these are easily derivable from those listed above.</p>
<h2 >axis ordering</h2>
<p >In every case the position on the axis is related to how far the node is from the current node.  The parent node is position 1 on the ancestor axis, the grandparent position 2 on the ancestor axis.  These positions are in document or reverse document order.  Document order is how close the node is on the printed page going from top to bottom.  Reverse document order is going on the page from bottom to top. Preceeding and ancestor nodes are in reverse document order, following and decendent nodes in document order.</p>
<h2 >location paths</h2>
<p >An xpath expression may result in a node set.  That is a set of qualifying nodes. The expression to find all decendents of the current node is &quot;decendents::node()&quot;.  The axis comes first, and then a node test which in this case returns any type of node whatsoever.  A location expression can contain several parts each separated by /.  Each part can be filtered by an expression in [].</p>
<example >
  <title >Find closest ancestor page which has a url node as it&apos;s child</title>
  <content >ancestor::page[child::url][position()=1]</content>
</example>   
<h2 >Abbreviated syntax</h2>
<p >The abbreviated syntax is as follows:</p>
<ul >
<li ><p >omitting an axis is short for &quot;child::&quot;</p></li>
<li ><p >&quot;.&quot; represents &quot;self::node()&quot;</p></li>
<li ><p >&quot;..&quot; represents &quot;parent::node()&quot;</p></li>
<li ><p >&quot;@&quot; represents &quot;attribute::&quot;</p></li>
<li ><p >&quot;//&quot; represents &quot;decendant-or-self::&quot;</p></li>
<li ><p >&quot;[number]&quot; represents &quot;[position()=number]&quot;</p></li>
</ul>
<p >Thus the previous example could be written &quot;ancestor::page[url][1]&quot;</p>
</content>
</page>
    <page  xmlns:ax="abc">
  <name >xslt</name>
  <title >xslt</title>
  <url >xslt.html</url>
  <keywords >xml</keywords>
  <pageheader >Greenrose</pageheader>
  <file_headers >&lt;!DOCTYPE html&gt;</file_headers>
<content >
<h2 >What is xslt?</h2>
<p >XSLT is an XML language designed to convert XML documents to other XML formats,
expecially XSL-FO.
XSL-FO is a stylesheet language, often used for formatting documents
prior to conversion to PDF. It can be used to generate other formats and is useful to convert
arbitary XML documents into XHTML.</p>
<h2 >Getting Started</h2>
<example >
<title >A simple XSLT stylesheet</title>
<content >
<pre >

&lt;xsl:stylesheet xmlns:xsl=&quot;http://www.w3.org/1999/XSL/Transform&quot; version=&quot;1.0&quot;&gt;
  &lt;xsl:template match=&quot;text()&quot;/&gt;
  &lt;xsl:template match=&apos;/site&apos;&gt;
    &lt;xsl:for-each select=&quot;./pages/page&quot;&gt;
      &lt;xsl:choose&gt;
	&lt;xsl:when test=&quot;ancestor::pages[navtype=&apos;mesh&apos;]&quot;&gt;
	  Found
	&lt;/xsl:when&gt;
      &lt;/xsl:choose&gt;
    &lt;/xsl:for-each&gt;
  &lt;/xsl:template&gt;
&lt;/xsl:stylesheet&gt;

</pre>
<p >The first line declares this XML to be an xslt stylesheet.  Note the use of the namespace.  The second line rule overrides default text node processing.  The default is to output text nodes.  This rule says do nothing. Note the match expressions on the &lt;xsl:template&gt; are xpath expressions.  The third line matches a root element &quot;site&quot;. Inside this element this root element becomes the self() or current node.  On the next line the for-each iterates through each /site/pages/page node, each node in turn becoming the self node.  For each page having an ancestor pages element, containing an element navtype whose text value is &quot;mesh&quot;, the value Found is output.  The reader should also note the test attribute of the when element is set to an xpath expression.   An empty nodeset is false.</p>
</content>
</example>
<p >The above example shows the interplay of xml technologies, XPATH, XSLT and 
XML Namespaces.  Once again it emphasises the need to grasp the basics such
as Namespaces and XPATH before moving onto other technologies such as XSLT.</p>
<p >There is much more to XSLT than the simple example shown here, the reader
is asked to do check out some of the online tutorials and download the XSLT standard.</p>
<h2 >XSLT processors</h2>
<p >Many XSLT processors only process version 1.0 XSLT, which uses XPATH 1.0.  Support for this standard is however widespread.</p>
<ul >
<li ><p >Firefox supports XSLT 1.O.  To transform your document in the browser, insert a processing instruction such as &lt;?xml-stylesheet href=&quot;xsltforms/xsltforms.xsl&quot; type=&quot;text/xsl&quot;?&gt; at the top of the file.</p></li>
<li ><p >The linux command xsltproc also support XSLT 1.0.</p></li>
</ul>  
</content>
</page>
    <page  xmlns:xi="http://www.w3.org/2001/XInclude" xmlns:ax="abc">
<name >static site</name>
<title >static site</title>
<url >static.html</url>
<keywords >xml</keywords>
<pageheader >Greenrose</pageheader>
<file_headers >&lt;!DOCTYPE html&gt;</file_headers>
<content >
<h2 >Why  build a site this way?</h2>
<p >In this lesson we will build a site with static content
using the tools we have learnt thus far.  Why do it this way?
A website can be viewed as an organised collection of pages.</p><p >Editing pages on an adhoc basis can lead to inconsistency
between pages.  This is partially overcome using shared css 
stylesheets, however this does not model the relationship 
between the pages.  Xml can model the relationship between
the web pages, be they nested or disjoint sets.</p>
<h2 >This site master file</h2>
<pre ><pre>&lt;site xmlns:xf=&quot;http://www.w3.org/2002/xforms&quot;
xmlns:xi=&quot;http://www.w3.org/2001/XInclude&quot;
xmlns:xhtml=&quot;http://www.w3.org/1999/xhtml&quot;&gt;
  &lt;siteurl&gt;www.tony.gen.nz/xml&lt;/siteurl&gt;
  &lt;html_dir&gt;html&lt;/html_dir&gt;
  &lt;resources&gt;
    &lt;copydir&gt;html&lt;/copydir&gt;
  &lt;/resources&gt;
  &lt;file_headers&gt;&lt;![CDATA[&lt;?xml version=&quot;1.0&quot;?&gt;&lt;!DOCTYPE html&gt;]]&gt;&lt;/file_headers&gt;
  &lt;pages&gt;
    &lt;homepage&gt;index.xhtml&lt;/homepage&gt;
    &lt;navtype&gt;mesh&lt;/navtype&gt;
    &lt;contact-phone&gt;Phone: 027 2203796&lt;/contact-phone&gt;
    &lt;contact-email&gt;&lt;xhtml:a href=&quot;mailto:tony@tony.gen.nz&quot;&gt;Email: tony@tony.gen.nz&lt;/xhtml:a&gt;&lt;/contact-email&gt;
    &lt;banner_image&gt;&lt;xhtml:img src=&quot;images/hw.png&quot; left=&quot;250px&quot; width=&quot;100%&quot; /&gt;&lt;/banner_image&gt;
    &lt;xi:include href=&quot;index.xml&quot; parse=&quot;xml&quot;/&gt;
  &lt;/pages&gt;
  &lt;pages&gt;
    &lt;homepage&gt;index.xhtml&lt;/homepage&gt;
    &lt;navtype&gt;mesh&lt;/navtype&gt;
    &lt;contact-phone&gt;Phone: 027 2203796&lt;/contact-phone&gt;
    &lt;contact-email&gt;&lt;xhtml:a href=&quot;mailto:tony@tony.gen.nz&quot;&gt;Email: tony@tony.gen.nz&lt;/xhtml:a&gt;&lt;/contact-email&gt;
    &lt;banner_image&gt;&lt;xhtml:img src=&quot;images/hw.png&quot; left=&quot;250px&quot; width=&quot;100%&quot; /&gt;&lt;/banner_image&gt;
    &lt;xi:include href=&quot;intro.xml&quot; parse=&quot;xml&quot;/&gt;
    &lt;xi:include href=&quot;whatsxml.xml&quot; parse=&quot;xml&quot;/&gt;
    &lt;xi:include href=&quot;xmlprocessing.xml&quot; parse=&quot;xml&quot;/&gt;
    &lt;xi:include href=&quot;namespaces.xml&quot;  parse=&quot;xml&quot;/&gt;
    &lt;xi:include href=&quot;xpath.xml&quot;  parse=&quot;xml&quot;/&gt;
    &lt;xi:include href=&quot;xslt.xml&quot; parse=&quot;xml&quot;/&gt;
    &lt;xi:include href=&quot;staticsite.xml&quot; parse=&quot;xml&quot;/&gt;
    &lt;xi:include href=&quot;validation.xml&quot; parse=&quot;xml&quot;/&gt;
    &lt;xi:include href=&quot;splitpages.xml&quot; parse=&quot;xml&quot; /&gt;
    &lt;xi:include href=&quot;inserting_content.xml&quot; parse=&quot;xml&quot; /&gt;
    &lt;xi:include href=&quot;build.xml&quot; parse=&quot;xml&quot; /&gt;
    &lt;xi:include href=&quot;future_development.xml&quot; parse=&quot;xml&quot; /&gt;
    &lt;xi:include href=&quot;rest.xml&quot; parse=&quot;xml&quot; /&gt;
  &lt;/pages&gt;
  &lt;pages&gt;
    &lt;homepage&gt;index.xhtml&lt;/homepage&gt;
    &lt;navtype&gt;mesh&lt;/navtype&gt;
    &lt;contact-phone&gt;Phone: 027 2203796&lt;/contact-phone&gt;
    &lt;contact-email&gt;&lt;a href=&quot;mailto:tony@tony.gen.nz&quot;&gt;Email: tony@tony.gen.nz&lt;/a&gt;&lt;/contact-email&gt;
    &lt;banner_image&gt;&lt;img src=&quot;images/hw.png&quot; left=&quot;250px&quot; width=&quot;100%&quot; /&gt;&lt;/banner_image&gt;
    &lt;xi:include href=&quot;addwebsite.xml&quot; parse=&quot;xml&quot; /&gt;
    &lt;xi:include href=&quot;admin_todo.xml&quot; parse=&quot;xml&quot; /&gt;
    &lt;xi:include href=&quot;admin_troubleshooting.xml&quot; parse=&quot;xml&quot; /&gt;
  &lt;/pages&gt;
&lt;/site&gt;
 
</pre></pre>
<h2 >This page definition</h2>

<p >This is the definition for this page.  Everything about this
page, its name, its url and all other things required for its
generation are stored here...</p>
<code ><pre>&lt;page  xmlns:ax=&quot;abc&quot; xmlns:xi=&quot;http://www.w3.org/2001/XInclude&quot;&gt;
&lt;name &gt;static site&lt;/name&gt;
&lt;title &gt;static site&lt;/title&gt;
&lt;url &gt;static.html&lt;/url&gt;
&lt;keywords &gt;xml&lt;/keywords&gt;
&lt;pageheader &gt;Greenrose&lt;/pageheader&gt;
&lt;file_headers &gt;&lt;![CDATA[&lt;!DOCTYPE html&gt;]]&gt;&lt;/file_headers&gt;
&lt;content &gt;
&lt;h2 &gt;Why  build a site this way?&lt;/h2&gt;
&lt;p &gt;In this lesson we will build a site with static content
using the tools we have learnt thus far.  Why do it this way?
A website can be viewed as an organised collection of pages.&lt;/p&gt;&lt;p &gt;Editing pages on an adhoc basis can lead to inconsistency
between pages.  This is partially overcome using shared css 
stylesheets, however this does not model the relationship 
between the pages.  Xml can model the relationship between
the web pages, be they nested or disjoint sets.&lt;/p&gt;
&lt;h2 &gt;This site master file&lt;/h2&gt;
&lt;pre &gt;&lt;xi:include  parse=&quot;text&quot; href=&quot;pagedata.xml&quot;&gt;&lt;/xi:include&gt;&lt;/pre&gt;
&lt;h2&gt;This page definition&lt;/h2&gt;

&lt;p&gt;This is the definition for this page.  Everything about this
page, its name, its url and all other things required for its
generation are stored here...&lt;/p&gt;
&lt;code&gt;&lt;xi:include href=&quot;staticsite.xml&quot; parse=&quot;text&quot;/&gt;&lt;/code&gt;

&lt;h2 &gt;An XSLT utility file&lt;/h2&gt;
&lt;p&gt;
This is one of two files for converting this site data into html.
&lt;/p&gt;
&lt;pre &gt;&lt;xi:include  parse=&quot;text&quot; href=&quot;ajw_utils.xsl&quot;&gt;&lt;/xi:include&gt;&lt;/pre&gt;&lt;h2 &gt;XSLT file to generate HTML&lt;/h2&gt;
&lt;p&gt;
This file generates each web page including navigation bar.
&lt;/p&gt;
&lt;xi:include  href=&quot;make_web.xsl&quot; parse=&quot;text&quot;&gt;&lt;/xi:include&gt;
&lt;h2&gt;Extra functionality from a SAX parser&lt;/h2&gt;
&lt;p&gt;During construction it was found that the xmllint
xinclude did not work properly with the parse=&quot;text&quot; attribute.
It was also required to find a way to split up the site into
separate html pages and to store and save into these pages
processing instructions.&lt;/p&gt;
&lt;p&gt;These functions were built using the erlsom SAX parser
and custom erlang programming.  The disadvantage of going
to SAX and erlang compared to using XSLT is obvious, the
program is much longer. However the advantage is that
using a general purpose language like erlang allows complete
flexibility.&lt;/p&gt;  
&lt;p&gt;Finally, there is a significant amount of code dedicated
to self testing.&lt;/p&gt;
&lt;p&gt;This code is shown here.&lt;/p&gt;
&lt;code&gt;
&lt;xi:include href=&quot;../src/xslt_extn.erl&quot; parse=&quot;text&quot; /&gt;
&lt;/code&gt;
&lt;h2 &gt;A build script to put it all together&lt;/h2&gt;
&lt;pre &gt;
&lt;![CDATA[
cd site_data
escript ../ebin/xslt_extn.beam &lt; pagedata.xml &gt; fullsite.xml 2&gt; errors.txt
xsltproc ../src/make_web2.xsl fullsite.xml &gt; allpages.xml
escript ../ebin/xslt_extn.beam +finaloutput &lt; allpages.xml 
mv *.html ../html
]]&gt;
&lt;/pre&gt;
&lt;p&gt;The first call to xslt_extn includes all the page
definitions in pagedata.xml creating the file fillsite.xml.
This data is then put through xslt processing to form a
new file allpages.xml.  This file has all the webpages
properly laid out, but all in a single file.  xslt_extn
is called again to split these files and output the
processing instructions into the web pages.  Finally
these html web pages are copied to the websites html directory.
&lt;/p&gt;
&lt;/content&gt;&lt;/page&gt;
</pre></code>

<h2 >An XSLT utility file</h2>
<p >
This is one of two files for converting this site data into html.
</p>
<pre ><pre>&lt;!--
Author:  Tony Wallace
Contact: tony@tony.gen.nz

Licence: This program is donated to the public domain.
Freely I have received, freely I give.

I acknowledge the work of the w3 consortium that made
this work possible.
--&gt;
&lt;!--
A few xslt utilities..

The cdata tag encloses the result of apply templates
into a ddata tag with a the data quoted by CDATA tags.
A ddata maintains the CDATA tags through processing
steps and stops the CDATA tags from disappearing by
putting ddata into the output cdata-section-elements.
--&gt;
&lt;xsl:stylesheet
  xmlns:xsl=&quot;http://www.w3.org/1999/XSL/Transform&quot; version=&quot;1.0&quot;
  xmlns:ax=&quot;abc&quot;&gt;
  
&lt;xsl:output method = &quot;xml&quot;/&gt;
&lt;xsl:template match=&quot;/&quot;&gt;
  &lt;xsl:apply-templates/&gt;
&lt;/xsl:template&gt;

&lt;xsl:template match=&quot;@*&quot;&gt;
  &lt;xsl:attribute name=&quot;{name()}&quot;&gt;
    &lt;xsl:message&gt;create attribute &lt;xsl:value-of select=&quot;name()&quot;/&gt; = 
         &lt;xsl:value-of select=&quot;.&quot; /&gt; &lt;/xsl:message&gt;
    &lt;xsl:value-of select=&quot;.&quot;/&gt;
  &lt;/xsl:attribute&gt;
&lt;/xsl:template&gt;

&lt;xsl:template match=&quot;text()&quot;&gt;
  &lt;xsl:value-of select=&quot;.&quot;/&gt;
&lt;/xsl:template&gt;

&lt;xsl:template match=&quot;node()&quot;&gt;
  &lt;xsl:message&gt;general match &lt;xsl:value-of select=&quot;name()&quot;/&gt;&lt;/xsl:message&gt;
  &lt;xsl:element name=&quot;{name()}&quot;&gt;
    &lt;xsl:apply-templates/&gt;
  &lt;/xsl:element&gt;
&lt;/xsl:template&gt;

&lt;xsl:template match=&quot;text()&quot; name=&quot;insertBreaks&quot; mode=&quot;crtobr&quot;&gt;
  &lt;xsl:param name=&quot;pText&quot; select=&quot;.&quot;/&gt;

  &lt;xsl:choose&gt;
    &lt;xsl:when test=&quot;not(contains($pText, &apos;&amp;#xA;&apos;))&quot;&gt;
      &lt;xsl:copy-of select=&quot;$pText&quot;/&gt;
    &lt;/xsl:when&gt;
    &lt;xsl:otherwise&gt;
      &lt;xsl:value-of select=&quot;substring-before($pText, &apos;&amp;#xA;&apos;)&quot;/&gt;
      &lt;br /&gt;
      &lt;xsl:call-template name=&quot;insertBreaks&quot;&gt;
	&lt;xsl:with-param name=&quot;pText&quot; select=
	  &quot;substring-after($pText, &apos;&amp;#xA;&apos;)&quot;/&gt;
      &lt;/xsl:call-template&gt;
    &lt;/xsl:otherwise&gt;
  &lt;/xsl:choose&gt;
&lt;/xsl:template&gt;
&lt;/xsl:stylesheet&gt;
</pre></pre><h2 >XSLT file to generate HTML</h2>
<p >
This file generates each web page including navigation bar.
</p>
<pre>&lt;?xml version=&quot;1.0&quot; encoding=&quot;ISO-8859-1&quot;?&gt;

&lt;!--
Note: xslt 1.0 cannot produce multiple output files
This will have to be done externally by a shell script
These directives are put into generated output by
^filename:&lt;filename&gt;$ lines
where &lt;filename&gt; is the text of the file name.

This will be done by short erlang program
through which this data file is piped.
--&gt;
&lt;xsl:stylesheet xmlns:xsl=&quot;http://www.w3.org/1999/XSL/Transform&quot; 
		xmlns:ax=&quot;abc&quot; version=&quot;1.0&quot;&gt;
  &lt;xsl:import href=&quot;ajw_utils.xsl&quot; /&gt;
  &lt;xsl:template match=&apos;/site&apos;&gt;
    &lt;xsl:for-each select=&quot;./pages&quot;&gt;
      &lt;xsl:apply-templates/&gt;
    &lt;/xsl:for-each&gt;
  &lt;/xsl:template&gt;

&lt;xsl:template match=&quot;pages&quot; name=&quot;pages-template&quot;&gt;
  &lt;xsl:for-each select=&quot;page&quot;&gt;
    &lt;xsl:apply-templates/&gt;
  &lt;/xsl:for-each&gt;
&lt;/xsl:template&gt;

&lt;xsl:template match=&quot;page&quot;&gt;
&lt;!-- Comment in template --&gt;
filename:&lt;xsl:value-of select=&quot;./url&quot; /&gt;
&lt;xsl:message&gt;File &lt;xsl:value-of select=&quot;./url&quot; /&gt;&lt;/xsl:message&gt;
&lt;xsl:text xml:space=&quot;preserve&quot; &gt;
&lt;/xsl:text&gt;
&lt;xsl:value-of disable-output-escaping=&quot;yes&quot; select=&quot;./file_headers&quot; /&gt;
&lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot; xmlns:xf=&quot;http://www.w3.org/2002/xforms&quot;&gt;

&lt;head&gt;
&lt;meta name=&quot;Keywords&quot; content=&apos;{keywords}&apos; /&gt;
&lt;!-- Comment in template --&gt;
&lt;title&gt;
  &lt;xsl:value-of select=&quot;./title&quot; /&gt;
&lt;/title&gt;
&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1&quot; /&gt;
&lt;!-- for efficiencies sake consider separte template file.
The advantage over inlining is that it gets loaded once for all pages --&gt;
&lt;style type=&quot;text/css&quot;&gt;
  body {color:blue;}  
  p  {line-height=130%;}
  h1 {text-align:center;}
  h2 {text-align:center;}
  h3 {text-align:center;}
  a:link {color:#0000FF;}
  a:visited {color:#C0C000;}
  nav {
  background-image:url(images/grgcleft2.png);
  position: absolute;
  top :0px;
  bottom:0;
  left: 0;
  width: 240px;
}
  section {
  position: relative;
  margin-left: 250px;
}
&lt;/style&gt;
  &lt;xsl:copy-of select=&quot;./model&quot; /&gt;

&lt;/head&gt;
&lt;body&gt;
  &lt;nav&gt;
  &lt;h2&gt;Contact&lt;/h2&gt;
  &lt;ul&gt;
  &lt;li&gt;&lt;xsl:value-of select=&quot;ancestor::pages/contact-phone&quot;/&gt;&lt;/li&gt;
  &lt;li&gt;&lt;xsl:copy-of  select=&quot;ancestor::pages/contact-email/*&quot;/&gt;&lt;/li&gt;
  &lt;xsl:choose&gt;
    &lt;xsl:when test=&quot;ancestor::pages[navtype=&apos;mesh&apos;]&quot;&gt;
      &lt;xsl:call-template name=&quot;meshindex&quot; /&gt;
    &lt;/xsl:when&gt;
    &lt;xsl:when test=&quot;ancestor::pages[navtype=&apos;linear&apos;]&quot;&gt;
      &lt;xsl:call-template name=&quot;linearindex&quot; /&gt;
    &lt;/xsl:when&gt;
    &lt;xsl:otherwise&gt;
      Failed to match index template:
      &lt;xsl:value-of select=&quot;ancestor::pages/navtype&quot;/&gt; 
      Current node is:
      &lt;xsl:value-of select=&quot;string(./node())&quot; /&gt;
    &lt;/xsl:otherwise&gt;
  &lt;/xsl:choose&gt;
  &lt;/ul&gt;
&lt;/nav&gt; 
&lt;section&gt;
  &lt;xsl:message&gt;section&lt;/xsl:message&gt;
  &lt;a&gt;
    &lt;xsl:attribute name=&quot;href&quot;&gt;
      &lt;xsl:value-of select=&quot;ancestor::pages/homepage&quot;/&gt;
    &lt;/xsl:attribute&gt;
    &lt;xsl:copy-of select=&quot;ancestor::pages/banner_image/child::img&quot;/&gt;
  &lt;/a&gt;
  &lt;br /&gt;
  &lt;xsl:apply-templates select=&quot;./content/*&quot;/&gt;
&lt;/section&gt;
&lt;/body&gt;
&lt;/html&gt;
     &lt;xsl:if test=&quot;./pages&quot;&gt;
       &lt;xsl:call-template name=&quot;pages-template&quot;/&gt;
     &lt;/xsl:if&gt;
  &lt;/xsl:template&gt;

&lt;xsl:template name=&quot;meshindex&quot;&gt;
    &lt;xsl:for-each select=&quot;ancestor::pages/page&quot;&gt;
      &lt;li&gt;
	&lt;a&gt;
	&lt;xsl:attribute name=&quot;href&quot;&gt;
	  &lt;xsl:value-of select=&quot;.//url&quot;  /&gt;
	&lt;/xsl:attribute&gt;
	&lt;xsl:value-of select=&quot;.//name&quot; /&gt;
	&lt;/a&gt;
      &lt;/li&gt;
    &lt;/xsl:for-each&gt;
&lt;/xsl:template&gt;

&lt;xsl:template name=&quot;linearindex&quot;&gt;
    Mesh linear index
    &lt;a href=&quot;{(ancestor::pages)[1]/page[1]/url}&quot;&gt;Home&lt;/a&gt;
    &lt;a href=&quot;{ancestor::pages/page[1]}&quot;&gt;Start&lt;/a&gt;
    &lt;a href=&quot;{ancestor::page/preceding-sibling::page[1]/url}&quot;&gt;Previous&lt;/a&gt;
    &lt;a href=&quot;{ancestor::page/following-sibling::page[1]/url}&quot;&gt;Next&lt;/a&gt;
&lt;/xsl:template&gt;


&lt;/xsl:stylesheet&gt;
</pre>
<h2 >Extra functionality from a SAX parser</h2>
<p >During construction it was found that the xmllint
xinclude did not work properly with the parse=&quot;text&quot; attribute.
It was also required to find a way to split up the site into
separate html pages and to store and save into these pages
processing instructions.</p>
<p >These functions were built using the erlsom SAX parser
and custom erlang programming.  The disadvantage of going
to SAX and erlang compared to using XSLT is obvious, the
program is much longer. However the advantage is that
using a general purpose language like erlang allows complete
flexibility.</p>  
<p >Finally, there is a significant amount of code dedicated
to self testing.</p>
<p >This code is shown here.</p>
<code >
<pre>%%
% Author:  Tony Wallace
% Contact: tony@tony.gen.nz
%
% Licence: This program is donated to the public domain.
% Freely I have received, freely I give.
%
% I acknowledge the work of the Ericsson Laboratories,
% the creators of erlang, that made this work possible.
%%
-module(xslt_extn).

%% An erlang module to provide:
%%  xinclude text file inclusion
%%  Splitting an xml file into several target files
%%    (like opposite of file inclusion)
%%  xml_text - this tag allows xml to be stored as escaped text
%%    and expanded again when &quot;final-output&quot; is performed
%%
%% Limitations:
%%  The xinclude functionality provided here does not conform to the
%%  standard in that many options provided for in the standard are ignored.
%% Author: Tony Wallace


%% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Modification:
%%  Copy inscope namespaces to first element after a &quot;file&quot; element.
%%  This is a consequence of the way XSLT 1.0 handles namespaces, and the requirement
%%  to split this output into several files.
%% Author: Tony Wallace
%% Date: 10 June 2015
%% ****************************************************


-export([main/1,doevent/2,file/1]).
-export([test/0,test1/0,test2/0,test3/0,test4/0,test5/0,test6/0,test7/0,test8/0,test9/0,test10/0]).
-include (&quot;erlsom_sax.hrl&quot;).
-record(startElement, {url,tag,prefix,attrlist}).
-record(endElement,{url,tag,prefix}).


%% debugging is provided if the debug_flag is compiled in.
%% from command line use: erlc -Ddebug_flag xslt_extn
%% in the erlang shell use: c(xslt_extn, {d,debug_flag}).
-ifdef(debug_flag).
-define (DEBUG(X), 
	 io:format(standard_error,
		   &quot;&lt;DEBUG module=\&quot;~p\&quot;~n line=\&quot;~p\&quot;~n timestamp=\&quot;~p\&quot;&gt;~n&lt;![CDATA[~p]]&gt;&lt;/DEBUG&gt;~n&quot;,
		   [?MODULE,?LINE,notime,X])).
-define (DEBUGSTR(X), 
	 io:format(standard_error,
		   &quot;&lt;DEBUG module=\&quot;~p\&quot;~n line=\&quot;~p\&quot;~n timestamp=\&quot;~p\&quot;&gt;~n&lt;![CDATA[~s]]&gt;&lt;/DEBUG&gt;~n&quot;,
		   [?MODULE,?LINE,notime,X])).

-define (DEBUG2(Msg,X), 
	 io:format(standard_error,
		   &quot;~s = ~p~n&quot;,
		   [Msg,X])).

-else.
-define (DEBUG(X), void).
-define (DEBUGSTR(X), void).
-define (DEBUG2(Msg,X), void).
-endif.
-define (PRESERVE_WHITESPACE_DEFAULT,true).
-define (FINAL_OUTPUT_DEFAULT,false).
-define (DATA_DIR,site_data).
default_state() -&gt;
       #{default_output =&gt; standard_io,
   	output =&gt; standard_io, 
	fileinclusions =&gt; ordsets:new(),
	tests =&gt; [],
	escape_to_xml =&gt; false,
	final_output =&gt; ?FINAL_OUTPUT_DEFAULT,
	preserve_whitespace =&gt; ?PRESERVE_WHITESPACE_DEFAULT,
	element_stack =&gt; [],
	output_namespaces =&gt; false,
	names_in_scope =&gt; []}.    

main(InputParameters) -&gt; 
    ?DEBUG(InputParameters),
    State0 = default_state(),
    State1 = lists:foldl(fun do_param/2,State0,InputParameters),
    %% discard output until first output file statement
    {ok,TestList} = maps:find(tests,State1),
    case TestList == [] of
	true -&gt;
	    file:set_cwd(?DATA_DIR),
	    Str=lists:flatten(read_stdin()),
	    parseStr(Str,State1);
	false -&gt;
	    ?DEBUG(TestList),
	    [do_test(T) || T &lt;- TestList]
    end.

file([Filename]) -&gt;
    file([Filename,[]]);
file([Filename,InputParameters]) -&gt;
    %% Purpose: to parse input from a file instead of stdin for testing purposes in erlang shell
    Dirname = filename:dirname(Filename),
    SavedDirName = filename:absname(&quot;.&quot;),
    State0 = default_state(),
    State1 = lists:foldl(fun do_param/2,State0,InputParameters),
    {ok,Str} = file:read_file(Filename),
    ok=file:set_cwd(Dirname), 
    parseStr(Str,State1),
    ok=file:set_cwd(SavedDirName).

do_param(&quot;+finaloutput&quot;,Si) -&gt;
    Si#{final_output =&gt; true};
do_param(&quot;-finaloutput&quot;,Si) -&gt;
    Si#{final_output =&gt; false};
do_param(&quot;+preserve_whitespace&quot;,Si) -&gt;
    Si#{preserve_whitespace =&gt; true};
do_param(&quot;-preserve_whitespace&quot;,Si) -&gt;
    Si#{preserve_whitespace =&gt; false};
do_param(T=[$t,$e,$s,$t|_],Si) -&gt;
    %% run tests...
    ?DEBUGSTR(&quot;Adding test to test list&quot;),
    ?DEBUG(T),
    {ok,OT} = maps:find(tests,Si),
    Si#{tests =&gt; [T|OT]};
do_param(Z,_) -&gt;
    throw(&quot;Unknown option &quot;++Z).


read_stdin() -&gt;
    lists:flatten(read_stdin(io:get_chars(standard_io,&quot;&quot;,8192))).
read_stdin(eof) -&gt;
    [];
read_stdin(Data) -&gt;
    [Data|read_stdin(io:get_chars(standard_io,&quot;&quot;,8192))].

parseStr(Str,State) -&gt;
    State2=State#{skip_end_tag =&gt; false, prefix_next_tag=&gt; [] },
    erlsom:parse_sax(Str,State2,fun doevent/2).

doevent(Event,State) -&gt;
    ?DEBUG(Event),
    {ok,OldFD} = maps:find(output,State),
    %% manage element stack
    {ok,ES} = maps:find(element_stack,State),
    {S1,ParentNS,ParentTag,_Ancestors} = 
	case ES of 
	    [] -&gt; 
		case Event of
		    {startElement,_,_,_,_} -&gt;
			{State#{element_stack =&gt; [Event | ES]},&quot;&quot;,&quot;&quot;,[]};
		    {endElement,_,_,_,_} -&gt;
			throw(&quot;Closing tag without an opening tag&quot;);
		    _ -&gt; 
			io:format(standard_error,&quot;No change to element stack which is empty~n&quot;,[]),
			{State,&quot;&quot;,&quot;&quot;,[]}
		end;
	    [{startElement,ParentNS1,ParentTag1,_,_}|Ancestors1] -&gt;
		case Event of
		    {startElement,_,_,_,_} -&gt;
			io:format(standard_error,&quot;Push start element onto stack~n&quot;,[]),
			{State#{element_stack =&gt; [Event | ES]},ParentNS1,ParentTag1,Ancestors1};
		    {endElement,NS,Tag,_,_} -&gt;
			case ParentNS1 =:= NS of
			    true -&gt; ok;
			    false -&gt; 
				throw(&quot;end element namespace does not start element&quot;)
			end,
			case Tag =:= ParentTag1 of
			    true -&gt; ok;
			    false -&gt;
				throw(&quot;end element tag does not match start element&quot;)
			end,
			{State#{element_stack =&gt; Ancestors1},ParentNS1,ParentTag1,Ancestors1};
		    A -&gt;
			io:format(standard_error,&quot;No change to element stack option2 ~n~p~n&quot;,[A]),
			{State,ParentNS1,ParentTag1,Ancestors1}
		end
	end,
    ?DEBUG2(&quot;S1&quot;,S1),
    R = case Event of
	{startElement,&quot;abc&quot;,&quot;file&quot;,_,AttrList} -&gt;
	    Filename = attrvalue(&quot;filename&quot;,AttrList),
	    S1#{output =&gt; set_output_file(Filename,OldFD), output_namespaces =&gt; true};
	OT2={startElement,&quot;abc&quot;,&quot;xml_tags&quot;,_,[]} -&gt;
	    {ok,FinalOutput} = maps:find(final_output,State),
	    case FinalOutput of
		true -&gt;
		    S1#{escape_to_xml =&gt; true};
	        false -&gt;
		    {ok,NSDecl2}=maps:find(prefix_next_tag,State),
		    write_open_tag(OT2,OldFD,NSDecl2),
		    S1
	    end;
	{startElement,
	 &quot;http://www.w3.org/2001/XInclude&quot;,&quot;include&quot;,_,AttrList} -&gt;
	    ?DEBUGSTR(&quot;xinclude start tag found&quot;),
	    Filename = attrvalue(&quot;href&quot;,AttrList),
	    Parse = attrvalue(&quot;parse&quot;,AttrList,&quot;xml&quot;),
	    case Parse of
		[] -&gt;
		    insert_file_xml(Filename,S1);
		&quot;xml&quot; -&gt;
		    insert_file_xml(Filename,S1);
		&quot;text&quot; -&gt;
		    insert_file_text(Filename,OldFD)
	    end,
	    S1;
	OT=#startElement{} -&gt;
	    ?DEBUGSTR(&quot;other start tag found&quot;),
	    {ok,NSDecl} = case maps:find(output_namespaces,State) of
		{ok,true} -&gt;
		    maps:find(names_in_scope,State);
		{ok,false} -&gt;
		    maps:find(prefix_next_tag,State)
	    end,
	    write_open_tag(OT,OldFD,NSDecl),
	    S1#{prefix_next_tag =&gt; &quot;&quot;,output_namespaces =&gt; false};
	{endElement,&quot;http://www.w3.org/2001/XInclude&quot;,&quot;include&quot;,_} -&gt;
	    S1;
	CT2={endElement,&quot;abc&quot;,&quot;xml_tags&quot;,_} -&gt;
	    {ok,FinalOutput} = maps:find(final_output,State),
	    case FinalOutput of
		true -&gt; 
		    ok; 
		false -&gt;
		    write_close_tag(CT2,OldFD)
	    end,
	    S1#{escape_to_xml =&gt; false};
	{endElement,&quot;abc&quot;,&quot;file&quot;,_} -&gt;
	    {ok,DefaultOutput} = maps:find(default_output,State),
	    State#{output =&gt; set_output_file(DefaultOutput,OldFD)};
	CT = #endElement{} -&gt;
	    {ok,ET} = maps:find(skip_end_tag,State),
	    case ET of
		true -&gt; 
		    S1#{skip_end_tag =&gt; false};
		false -&gt;
		    write_close_tag(CT,OldFD),
		    S1
	    end;
	{characters,Characters} -&gt;
	    {ok,Esc} = maps:find(escape_to_xml,State),
	    {ok,FinalOutput} = maps:find(final_output,State),
	    OutputChars =
	       case Esc and FinalOutput of
		   true -&gt;
		       reverse_escaping(Characters);
		   false -&gt;
		       xml_output_escaping(Characters)
	       end,
	    write_characters(OutputChars,OldFD),
	    S1;
	{processingInstruction,Type,Value} -&gt;
	    io:fwrite(OldFD,&quot;~s&quot;,[&quot;&lt;?&quot;++Type++Value++&quot;?&gt;&quot;]),
	    S1;
	{startPrefixMapping,Prefix,Url} -&gt;
	    {ok,PrefixNextTag} = maps:find(prefix_next_tag,State),
	    {ok,OldNamesInScope} = maps:find(names_in_scope,State),
	    S1#{
	      prefix_next_tag =&gt; [{Prefix,Url}|PrefixNextTag], 
	      names_in_scope =&gt; 
		  lists:keystore(Prefix,1,OldNamesInScope,{Prefix,Url})};
	{ignorableWhitespace,String} -&gt;
	    %% ignore whitespace after a xml_tags tag
	    {ok,P} = maps:find(preserve_whitespace,State),
	    PreserveWhitespace = 
		    P and not
		       ((ParentTag ==&quot;file&quot;) and (ParentNS==&quot;abc&quot;)),
	    case PreserveWhitespace of
		true -&gt;
		    write_characters(String,OldFD);
		false -&gt; 
		    ok
	    end,
	    S1;
	_ -&gt; S1
    end,
    ?DEBUG(R),
    io:format(standard_error,&quot;~n&quot;,[]),
    R.
    
attrvalue(AttName,AttrList) -&gt;
    attrvalue(AttName,AttrList,throw).

attrvalue(AttName,[],throw) -&gt;
    throw(&quot;Attribute &quot;++AttName++&quot; not found&quot;);
attrvalue(_,[],Default) -&gt;
    Default;
attrvalue(AttName,[#attribute{localName=AttName,value=Value}|_],_) -&gt;
    Value;
attrvalue(AttName,[_|T],Default) -&gt;
    attrvalue(AttName,T,Default).

-spec set_output_file(string()) -&gt; integer().
set_output_file(FileName) -&gt;
    ?DEBUGSTR(&quot;setting output directory to&quot;),
    ?DEBUG(FileName),
    ?DEBUGSTR(&quot;current directory is&quot;),
    ?DEBUG(filename:absname(&quot;.&quot;)),

    {ok,F}=file:open(FileName,[write]),
    F.

set_output_file(FileName,standard_io) -&gt;
    set_output_file(FileName);

set_output_file(FileName,OldFd) -&gt;
    ok=file:close(OldFd),
    {ok,F} = file:open(FileName,[write]),
    F.

insert_file_xml(Filename,State) -&gt;
    {ok,I} = maps:find(fileinclusions,State),
    State2 = case ordsets:is_element(Filename,I) of
	true -&gt;
	    throw(&quot;recursive xinclude on file &quot;++Filename);
	false -&gt;
	    State#{fileinclusions =&gt; ordsets:add_element(Filename,I)}
    end,
    Str =
	case file:read_file(Filename) of
	    {ok,Str2} -&gt; Str2;
	    {X,Y} -&gt; 
		io:format(standard_error,&quot;Could not read file ~s~n&quot;,[Filename]),
		throw({X,Y})
	end,
    erlsom:parse_sax(Str,State2,fun doevent/2).
    
-spec insert_file_text(string(), integer()) -&gt; ok.
insert_file_text(Filename,FD) -&gt; 
    Str1 =
	case file:read_file(Filename) of
	    {ok,Str} -&gt; Str;
	    {error,enoent} -&gt;
		throw (lists:flatten(io_lib:format(&quot;missing file ~s&quot;,[Filename])))
	end,
    Str2 = xml_output_escaping(binary_to_list(Str1)),
    io:fwrite(FD,&quot;~s&quot;,[&quot;&lt;pre&gt;&quot;]),
    io:fwrite(FD,&quot;~s&quot;,[Str2]),
    io:fwrite(FD,&quot;~s&quot;,[&quot;&lt;/pre&gt;&quot;]).

xml_parameter_formatting(X) -&gt;
    xml_output_escaping(lists:flatten(io_lib:write(X))).

xml_output_escaping(S) -&gt;
    [case X of 
	$&lt; -&gt; &quot;&amp;lt;&quot;; 
	$&quot; -&gt; &quot;&amp;quot;&quot;; 
	$&gt; -&gt; &quot;&amp;gt;&quot;; 
	$&apos; -&gt; &quot;&amp;apos;&quot;; 
	$&amp; -&gt; &quot;&amp;amp;&quot;; 
	_ -&gt; X 
    end 
    || X &lt;- S ].

reverse_escaping(S) -&gt;
    reverse_escaping(S,[]).

reverse_escaping([$&amp;|T],Q) -&gt;
    reverse_escape(T,[$&amp;],Q);
reverse_escaping([H|T],Q) -&gt;
    reverse_escaping(T,[H|Q]);
reverse_escaping([],Q) -&gt;
    lists:reverse(Q).

reverse_escape(S,&quot;&amp;lt;&quot;,Q) -&gt;
    reverse_escaping(S,[$&lt;|Q]);
reverse_escape(S,&quot;&amp;quot;&quot;,Q) -&gt;
    reverse_escaping(S,[$&quot;|Q]);
reverse_escape(S,&quot;&amp;gt;&quot;,Q) -&gt;
    reverse_escaping(S,[$&gt;|Q]);
reverse_escape(S,&quot;&amp;apos;&quot;,Q) -&gt;
    reverse_escaping(S,[$&apos;|Q]);
reverse_escape(S,&quot;&amp;amp;&quot;,Q) -&gt;
    reverse_escaping(S,[$&amp;|Q]);
reverse_escape([X|S],A,Q) when length(A) &lt; 6 -&gt;
    reverse_escape(S,A++[X],Q);
reverse_escape(_,Seq,_) -&gt;
    throw(&quot;Invalid escape sequence &quot;++Seq).

write_open_tag({startElement,_,Tag,&quot;&quot;,AttrList},FD,NSDecl) -&gt;
    ?DEBUGSTR(&quot;write_open_tag rule1&quot;),
    ?DEBUG(NSDecl),
    io:fwrite(FD,&quot;~s&quot;,[&quot;&lt;&quot;++Tag++&quot; &quot;]), 
    ok=write_name_decl(NSDecl,FD),
    write_attributes(AttrList,FD),
    io:fwrite(FD,&quot;~s&quot;,[&quot;&gt;&quot;]);

write_open_tag({startElement,_,Tag,Prefix,AttrList},FD,NSDecl) -&gt;
    ?DEBUGSTR(&quot;write_open_tag rule2&quot;),
    io:format(standard_error,&quot;write_open_tag ~n  Prefix=~s~n  Tag=~s~n  Attributes=~p~n  Namespaces=~p~n&quot;,[Prefix,Tag,AttrList,NSDecl]),
    io:fwrite(FD,&quot;~s&quot;,[&quot;&lt;&quot;++Prefix++&quot;:&quot;++Tag++&quot; &quot;]), 
    ok=write_name_decl(NSDecl,FD),
    write_attributes(AttrList,FD),
    io:fwrite(FD,&quot;~s&quot;,[&quot;&gt;&quot;]).

write_close_tag({endElement,_,LocalName,&quot;&quot;}, FD)-&gt;
   io:fwrite(FD,&quot;~s&quot;,[&quot;&lt;/&quot;++LocalName++&quot;&gt;&quot;]);

write_close_tag({endElement,_,LocalName,Prefix},FD) -&gt;
    io:fwrite(FD,&quot;~s&quot;,[&quot;&lt;/&quot;++Prefix++&quot;:&quot;++LocalName++&quot;&gt;&quot;]).

write_name_decl([],_) -&gt;
    ok;
write_name_decl([{&quot;&quot;,Url}|T],FD) -&gt; 
    NS = &quot; xmlns=\&quot;&quot;++Url++&quot;\&quot;&quot;,
    io:format(standard_error,&quot;write_name_decl (no prefix) url=~s~n&quot;,[Url]),
    io:fwrite(FD,&quot;~s&quot;,[NS]),
    write_name_decl(T,FD);
    
write_name_decl([{Prefix,Url}|T],FD) -&gt;
    NS = &quot; xmlns:&quot;++Prefix++&quot;=\&quot;&quot;++Url++&quot;\&quot;&quot;,
    ?DEBUG(NS),
    io:format(standard_error,&quot;write_name_decl prefix=~s url=~s~n&quot;,[Prefix,Url]),
    io:fwrite(FD,&quot;~s&quot;,[NS]),
    write_name_decl(T,FD).

write_attributes([],_) -&gt;  ok;
write_attributes([{attribute,LocalName,_Uri,Prefix,Value}|T],FD) -&gt;
    io:fwrite(FD,&quot;~s&quot;,[&quot; &quot;++Prefix++LocalName++&quot;=\&quot;&quot;++Value++&quot;\&quot;&quot;]),
    write_attributes(T,FD).

write_characters(String,FD) -&gt;
    io:fwrite(FD,&quot;~s&quot;,[String]).


do_test(&quot;test&quot;) -&gt;
    test();
do_test(&quot;test1&quot;) -&gt;
    test1();
do_test(&quot;test2&quot;) -&gt;
    test2();
do_test(&quot;test3&quot;) -&gt;
    test3();
do_test(&quot;test4&quot;) -&gt;
    test4();
do_test(&quot;test5&quot;) -&gt;
    test5();
do_test(&quot;test6&quot;) -&gt;
    test6();
do_test(&quot;test7&quot;) -&gt;
    test7();
do_test(&quot;test8&quot;) -&gt;
    test8();
do_test(&quot;test9&quot;) -&gt;
    test9();
do_test(&quot;test10&quot;) -&gt;
    test10();
do_test(X) -&gt;
    throw(&quot;unknown test &quot;++X).

test() -&gt;
    io:format(&quot;testing started, current directory is ~n~s~n&quot;,[filename:absname(&quot;.&quot;)]),
    test1(),
    test2(),
    test3(),
    test4(),
    test5(),
    test6(),
    test7(),
    test8(),
    test9(),
    test10(),
    ok.

test1() -&gt;
    Testid = &quot;test1&quot;,
    InputFile = &quot;test/input/test1.xml&quot;,
    OutputFile = filename:join([&quot;test/output&quot;,Testid])++&quot;.xml&quot;,
    ErrorFile = filename:join([&quot;test/output&quot;,Testid])++&quot;.err.txt&quot;,
    Options = &quot;&quot;,
    io:format(standard_error,&quot;~s~n&quot;,[Testid]),
    Cmd = &quot;escript ebin/xslt_extn.beam &quot;++ Options ++&quot; &lt; &quot; 
	++ InputFile ++ &quot; &gt; &quot; ++ OutputFile
	++ &quot; 2&gt; &quot; ++ ErrorFile,
    ?DEBUG(Cmd),
    os:cmd(Cmd),
    ok.

test2() -&gt;
    Testid = &quot;test2&quot;,
    InputFile = &quot;test/input/testinclusion.xml&quot;,
    OutputFile = filename:join([&quot;test/output&quot;,Testid])++&quot;.xml&quot;,
    ErrorFile = filename:join([&quot;test/output&quot;,Testid])++&quot;.err.txt&quot;,
    Options = &quot;&quot;,
    io:format(standard_error,&quot;~s~n&quot;,[Testid]),
    Cmd = &quot;escript ebin/xslt_extn.beam &quot;++ Options ++&quot; &lt; &quot; 
	++ InputFile ++ &quot; &gt; &quot; ++ OutputFile
	++ &quot; 2&gt; &quot; ++ ErrorFile,
    ?DEBUG(Cmd),
    os:cmd(Cmd),
    ok.
    
test3() -&gt;
    Testid = &quot;test3&quot;,
    InputFile = &quot;test/input/testinclusion2.xml&quot;,
    OutputFile = filename:join([&quot;test/output&quot;,Testid])++&quot;.xml&quot;,
    ErrorFile = filename:join([&quot;test/output&quot;,Testid])++&quot;.err.txt&quot;,
    Options = &quot;&quot;,
    io:format(standard_error,&quot;~s~n&quot;,[Testid]),
    Cmd = &quot;escript ebin/xslt_extn.beam &quot;++ Options ++&quot; &lt; &quot; 
	++ InputFile ++ &quot; &gt; &quot; ++ OutputFile
	++ &quot; 2&gt; &quot; ++ ErrorFile,
    ?DEBUG(Cmd),
    os:cmd(Cmd),
    ok.
    
test4() -&gt;
    Testid = &quot;test4&quot;,
    InputFile = &quot;test/input/testinclusion3.xml&quot;,
    OutputFile = filename:join([&quot;test/output&quot;,Testid])++&quot;.xml&quot;,
    ErrorFile = filename:join([&quot;test/output&quot;,Testid])++&quot;.err.txt&quot;,
    Options = &quot;&quot;,
    Cmd = &quot;escript ebin/xslt_extn.beam &quot;++ Options ++&quot; &lt; &quot; 
	++ InputFile ++ &quot; &gt; &quot; ++ OutputFile
	++ &quot; 2&gt; &quot; ++ ErrorFile,
    ?DEBUG(Cmd),
    os:cmd(Cmd),
    ok.
    
test5() -&gt;
    io:format(&quot;test5~n&quot;),
    InputFile = &quot;test/input/test_file_output.xml&quot;,
    OutputFile = &quot;test/output/test5.xml&quot;,
    ErrorFile = &quot;test/output/test5.err.txt&quot;,
    Options = &quot;+finaloutput&quot;,
    Cmd = &quot;escript ebin/xslt_extn.beam &quot;++ Options ++&quot; &lt; &quot; 
	++ InputFile ++ &quot; &gt; &quot; ++ OutputFile
	++ &quot; 2&gt; &quot; ++ ErrorFile,
    ?DEBUG(Cmd),
    os:cmd(Cmd),
    ok.

test6() -&gt;
    Testid = &quot;test6&quot;,
    OutputFile = filename:join([&quot;test/output&quot;,Testid])++&quot;.xml&quot;,
    io:format(standard_error,&quot;~s~n&quot;,[Testid]),
    Fd = set_output_file(OutputFile),
    {ok,Str} = file:read_file(&quot;test/input/test_namespaces.xml&quot;),
    S0 = default_state(),
    parseStr(Str,S0#{output =&gt; Fd}),
    ok.

test7() -&gt;    
    Testid = &quot;test7&quot;,
    io:format(standard_error,&quot;~s~n&quot;,[Testid]),
    %% Test recursive xml include
    InputFile = &quot;test/input/recursive_include_xml.xml&quot;,
    OutputFile = &quot;test/output/test7.xml&quot;,
    ErrorFile = &quot;test/output/test7.err.txt&quot;,
    Options = &quot;&quot;,
    Cmd = &quot;escript ebin/xslt_extn.beam &quot;++ Options ++&quot; &lt; &quot; 
	++ InputFile ++ &quot; &gt; &quot; ++ OutputFile
	++ &quot; 2&gt; &quot; ++ ErrorFile,
    os:cmd(Cmd).

test8() -&gt;
    %% test reverse escaping
    &quot;&lt;tag&gt;&quot; = reverse_escaping(&quot;&amp;lt;tag&amp;gt;&quot;),
    &quot;a&lt;tag&gt;b&quot; = reverse_escaping(&quot;a&amp;lt;tag&amp;gt;b&quot;),
    &quot;\&quot;hi\&apos;&quot; = reverse_escaping(&quot;&amp;quot;hi&amp;apos;&quot;),
    &quot;&amp;&quot; = reverse_escaping(&quot;&amp;amp;&quot;),
    ok.

test9() -&gt;
    %% test xml_tags  +finaloutput (default)
    %% expect validly formed xml output
    %% expect tags in escaped format
    %% test reverse escaping in final output
    InputFile = &quot;test/input/xml_tags_tag.xml&quot;,
    OutputFile = &quot;test/output/test9.xml&quot;,
    ErrorFile = &quot;test/output/error9.txt&quot;,
    Options = &quot;+finaloutput&quot;,
    %% test relative directories okay
    true = filelib:is_dir(&quot;test/input&quot;),
    true = filelib:is_dir(&quot;test/output&quot;),
    %% generate test data
    Data = [&quot;&lt;root xmlns:q=\&quot;abc\&quot;&gt;&quot;,
	     &quot;&lt;q:xml_tags&gt;&amp;lt;tag/&amp;gt;&lt;/q:xml_tags&gt;&quot;,
	     &quot;&lt;/root&gt;&quot;],
    file:write_file(InputFile,
		    Data),
    %% run test
    ?DEBUGSTR(&quot;Test9 running test&quot;),
    Cmd = &quot;escript ebin/xslt_extn.beam &quot;++Options++&quot; &lt; &quot; 
	++ InputFile ++ &quot; &gt; &quot; ++ OutputFile
	++ &quot; 2&gt; &quot; ++ ErrorFile,
    ?DEBUG(Cmd),
    os:cmd(Cmd),
    %% check result

    case filelib:is_regular(OutputFile) of
	true -&gt;
	    {ok,R} = file:read_file(OutputFile),
	    io:format(&quot;~s~n&quot;,[R]);
	false -&gt;
	    throw(&quot;test 9 did not generate an output file&quot;)
    end.

test10() -&gt;
    %% test xml_tags not final output (default)
    %% expect validly formed xml output
    %% expect tags in escaped format
    InputFile = &quot;test/input/xml_tags_tag.xml&quot;,
    OutputFile = &quot;test/output/test10.xml&quot;,
    ErrorFile = &quot;test/output/error10.txt&quot;,
    Options = &quot;&quot;,
    %% test relative directories okay
    true = filelib:is_dir(&quot;test/input&quot;),
    true = filelib:is_dir(&quot;test/output&quot;),
    %% generate test data
    Data = [&quot;&lt;root xmlns:q=\&quot;abc\&quot;&gt;&quot;,
	     &quot;&lt;q:xml_tags&gt;&amp;lt;tag/&amp;gt;&lt;/q:xml_tags&gt;&quot;,
	     &quot;&lt;/root&gt;&quot;],
    file:write_file(InputFile,
		    Data),
    %% run test
    ?DEBUGSTR(&quot;Test10 running test&quot;),
    Cmd = &quot;escript ebin/xslt_extn.beam &quot;++Options++&quot;&lt; &quot; 
	++ InputFile ++ &quot; &gt; &quot; ++ OutputFile
	++ &quot; 2&gt; &quot; ++ ErrorFile,
    ?DEBUG(Cmd),
    os:cmd(Cmd),
    %% check result

    case filelib:is_regular(OutputFile) of
	true -&gt;
	    {ok,R} = file:read_file(OutputFile),
	    io:format(&quot;~s~n&quot;,[R]);
	false -&gt;
	    throw(&quot;test 10 did not generate an output file&quot;)
    end.
    
</pre>
</code>
<h2 >A build script to put it all together</h2>
<pre >

cd site_data
escript ../ebin/xslt_extn.beam &lt; pagedata.xml &gt; fullsite.xml 2&gt; errors.txt
xsltproc ../src/make_web2.xsl fullsite.xml &gt; allpages.xml
escript ../ebin/xslt_extn.beam +finaloutput &lt; allpages.xml 
mv *.html ../html

</pre>
<p >The first call to xslt_extn includes all the page
definitions in pagedata.xml creating the file fillsite.xml.
This data is then put through xslt processing to form a
new file allpages.xml.  This file has all the webpages
properly laid out, but all in a single file.  xslt_extn
is called again to split these files and output the
processing instructions into the web pages.  Finally
these html web pages are copied to the websites html directory.
</p>
</content></page>
    <page  xmlns:xi="http://www.w3.org/2001/XInclude">
  <name >Validation</name>
  <title >Validation</title>
  <url >validation.html</url>
  <keywords >xml</keywords>
  <pageheader ></pageheader>
  <file_headers ></file_headers>
  <header ></header>
  <content >
<p >Xml validation is the process of checking that
an xml document follows the rules for that type
of document.</p>
<p >This validation is essential so that the tools (such as templates)
can operate on the data.  Validating the xml is a good way of
preventing errors later.  These validation rules are written in
some form of formalised language.  Many languages can be used
for this purpose, for example a validation template could be
written in xslt and xpath.  Languages commonly used for validation
include DTD&apos;s, XML Schema and RelaxNG.</p>
<p >The choice of validation languages is influenced by the toolsets
in use, company policy and other considerations.  In this case
the choice of <a  href="http://relaxng.org/spec-20011203.html">RelaxNG</a>, 
<a  href="http://relaxng.org/compact.html">compact syntax</a>, 
was chosen for compatibility
with the emacs editor.  </p>
<p >The relaxng specification for this project is:
<pre>namespace xi=&quot;http://www.w3.org/2001/XInclude&quot;
namespace ax=&quot;abc&quot;

start = (sitespec | pagespec)

# This file specifies a website definition
# The data specified here is combined with
# the site template to produce the website.

# This data is accessed by xpath, formed
# into nodesets and inserted into the template
# at defined places.  The content of the
# elements is thus fragments of the target language
# (normally html).

# This file validates the site file
# and the individual pages.  These individual
# pages may be in separate files for modularity.
# For this reason xinclude statements are
# accepable page definitions in the site file.

anyElement =
  element * 
  {
    (attribute * { text }
     | text
     | anyElement) *}

nodeset =
  (anyElement* | text )  

pagespec =
(
  element xi:include
  {
    attribute href { text },
    attribute parse { &quot;xml&quot; }?
  } |
  element page
  {
    element name { text },
    element title { text },
    element url { text },
    element keywords { text },
    element pageheader { text },
    element file_headers { text }?,
    element header { nodeset }? ,
    element todo {text}* ,
    element ax:content { nodeset }
  }
)

sitespec =
  element site 
  {
    element siteurl{ text },
    element html_dir{ text },
    element resources{
      element copydir {text}
    },
    element file_headers {text},
    element pages
    {
      element homepage { text },
      element navtype { &quot;mesh&quot; | &quot;list&quot; },
      element contact-phone {  nodeset  },
      element contact-email {  nodeset  },
      element file_headers { text }?,
      element banner_image { nodeset },
      pagespec +
    } +
  }</pre>
</p>
  </content>
</page>
    <page  xmlns:ax="abc" xmlns:xi="http://www.w3.org/2001/XInclude">
  <name >split_pages</name>
  <title >Split Pages</title>
  <url >splitpages.html</url>
  <keywords >xml</keywords>
  <pageheader >Greenrose</pageheader>
  <file_headers >&lt;!DOCTYPE html&gt;</file_headers>
<content >
<h2 >Split Pages</h2>
<p >My original idea was that the pagedata.xml would define the
relationship between pages, and style information for the site.
A build process would use this information to build the html
webpages and each webpage would come out as a separate file.</p>
<p >Upon reflection I recognise that the whole website
could have been created as a single file and intrapage  
links used to get around the page.  The purpose of this site
is to document how it is not what it may have been, and
this page splitting functionality is part of the existing design</p>

<p >As XSLT 1.0 does not have the ability
to save each page to a separate file, this is done by an external
script written in Erlang.  Any suitable language could be used
for this task.</p>
<h3 >splitpages.escript</h3>
<p >In this case the make_web.xsl emits a line starting with
&quot;filename: FileNameValue&quot; where a new file named FileNameValue
should be started.
</p>
<p >The <a  href="splitpages.escript">splitpages</a> source code can be viewed here.</p>
<h3 >The abc:file tag</h3>
<p >Another approach to splitting the pages has been to define
an &quot;file&quot; tag in the &quot;abc&quot; namespace.  The source code here
is again written in erlang, but this time the input is read by
the erlsom SAX parser.</p>
<p >Most of the code is merely copying the input xml to the output.</p>
<p >The <a  href="xslt_extn.erl">xslt_extn</a> source code can be read here.</p>
<p >This code also includes a parse=&quot;text&quot; version of xinclude as the xmllint
version of this appears to be broken.</p>
</content>
</page>
    <page  xmlns:ax="abc" xmlns:xi="http://www.w3.org/2001/XInclude">
  <name >insert_content</name>
  <title >Insert Content</title>
  <url >insert.html</url>
  <keywords >xml</keywords>
  <pageheader >Greenrose</pageheader>
  <file_headers >&lt;!DOCTYPE html&gt;</file_headers>
<content >
<h2 >Inserting Content</h2>
<p >Xml include is used to copy pages into the XML dataset at
appropriate places.  This is done in the <a  href="static.html#xslt_extn">xslt_extn</a> sax parser.</p>
<h3 >Xml insert code</h3>
<pre >
insert_file_xml(Filename,State) -&gt;
    {ok,I} = maps:find(fileinclusions,State),
    State2 = case ordsets:is_element(Filename,I) of
	true -&gt;
	    throw(&quot;recursive xinclude on file &quot;++Filename);
	false -&gt;
	    State#{fileinclusions =&gt; ordsets:add_element(Filename,I)}
    end,
    {ok,Str} = file:read_file(Filename),
    erlsom:parse_sax(Str,State2,fun doevent/2).
</pre>
<p >
The bit of the insert_file_xml that does the work are the two lines at the bottom that read the file and then recursively call the erlsom:parse_sax procedure.  This allows xml file inclusions to be nested.</p>
<h3 >Text insert code</h3>
<pre >
-spec insert_file_text(string(), integer()) -&gt; ok.
insert_file_text(Filename,FD) -&gt; 
    {ok,Str} = file:read_file(Filename),
    Str2 = xml_output_escaping(binary_to_list(Str)),
    io:fwrite(FD,&quot;~s&quot;,[&quot;&lt;pre&gt;&quot;]),
    io:fwrite(FD,&quot;~s&quot;,[Str2]),
    io:fwrite(FD,&quot;~s&quot;,[&quot;&lt;/pre&gt;&quot;]).
    </pre>
<p >
This code reads the file, escapes all the xml characters, and writes it to output inside some &lt;pre&gt; tags to preserve the file formatting.
</p>
</content>
</page>
    <page  xmlns:xi="http://www.w3.org/2001/XInclude">
  <name >build</name>
  <title >Building the website</title>
  <url >build.html</url>
  <keywords >xml</keywords>
  <pageheader >Tony Gen</pageheader>
  <file_headers >&lt;!DOCTYPE html&gt;</file_headers>
<content >
  <p >
Once the website static pages are generated, there is a need to
build these pages into a webserver for deployment.  The process
for this is as follows:
  </p>
<ol >

<li >Ensure there is a site directory in website/clients</li>
<li >Copy the website data into website/clients/&lt;client&gt;/web_root</li>
<li >Ensure there is a handler defined in website/siteconf</li>
<li >Build the website</li>
<li >Test the build</li>
<li >Preparing the webserver</li>
<li >Install</li>
</ol>
<h3 >Writing a siteconf</h3>
<p >The following is siteconf file for this website.</p>
<pre >
<pre>-module(tonygenconfig).

-export([routing/2]).

routing(SiteName,DataDir) -&gt;
    ExtSite = lists:append([&quot;[...]&quot;,SiteName]),
    IdxFile = filename:join(DataDir,&quot;tonygen/web_root/index.html&quot;),
    StaticDir = filename:join(DataDir,&quot;tonygen/web_root&quot;),
    true = filelib:is_regular(IdxFile),
    true = filelib:is_dir(StaticDir),
    {ExtSite,
	[
	 {&quot;/&quot;, ajw_cowboy_static, {file, IdxFile}},
	 {&quot;/[...]&quot;, ajw_cowboy_static, {dir, StaticDir}}
	]
    }.
</pre>
</pre>
<h3 >Building a website</h3>
  <h4 >The initial make</h4>
<p >The build is started by executing the command:</p>
<pre >
  make
</pre><p >
In the website code directory.</p>
<p >This build process uses relx to make an erlang install set.  Including
all runtime libraries, compiled for the current architecture.  After this the
content is then added to the build with the command:</p>
<pre >
  make static-pages
</pre>
<p >The content added by this command includes:</p>
<ul >
  <li >Static web pages</li>
  <li >Installation utilites</li>
</ul>
<p >At the end of the build process, the release is stored in a directory _rel.</p>
  <h4 >Contents of the makefile</h4>
<pre ><pre>PROJECT = website

DEPS = cowboy
dep_cowboy = pkg://cowboy master

include vsn.mk
VSN = 0.0.1

.PHONY: release clean-release static-pages

release: clean-release all 
	./relx -o rel/$(PROJECT)
	static-pages

clean-release: clean-rel
	rm -rf rel/$(PROJECT)

static-pages:
	rm -rf $(PROJECT)/$(PROJECT)/lib/*/src
	cp -r clients rel/$(PROJECT)/$(PROJECT)
	cp installer/install.sh rel/$(PROJECT)
	chmod +x rel/$(PROJECT)/install.sh
	rm -rf rel/$(PROJECT)/installer
	mkdir rel/$(PROJECT)/installer
#	mkdir /rel/$(PROJECT)/installer
	cp installer/website.src rel/$(PROJECT)/installer/website.src
	cp readme.txt rel/$(PROJECT)
#	sh mktar.sh $(PROJECT)	
#	tar -Avz clients installer

include ../erlang.mk

</pre></pre>
  <h4 >The installer</h4>
<p >The installer puts a script into /etc/init.d/ to start the webserver.
Links to this script are put into the rc&lt;runlevel&gt;.d directories
so that the webserver is started and stopped automatically.  The webserver
is run as a non-priveilaged user for security purposes, the username
for this user being a parameter in the install.  At the time the install
is made the same information is used to make an uninstall script.</p>
<h5 >install.sh</h5>
<pre ><pre># install embedded erlang application built with relx
# replaces string %FINAL_ROOT_DIR% with installdir
# in accordance with Erlang System Manual section
# Installing a Target System
# usage: install &lt;application&gt;
# The tarball has been copied to the directory where it will
# be installed, and this install script installs it.

APP=$1

if [ &quot;$2&quot; = &quot;&quot; ]; then 
    echo &quot;Usage install &lt;application&gt; &lt;user&gt;&quot;
    exit 1
else
    USER=$2

#tar -xvz $APP.tar.gz 

    ROOTDIR=$APP
    FULLPATH=`pwd`/$APP
    DataFile=$ROOTDIR/releases/start_erl.data

    ERTS_VSN=`awk &apos;{print $1}&apos; $DataFile`
    VSN=`awk &apos;{print $2}&apos; $DataFile`

    RL1=K75$APP
    RL2=S75$APP
    RL3=S75$APP
    RL4=S75$APP
    RL5=S75$APP
    RL6=K75$APP

# make uninstaller
    echo &apos;sudo /etc/init.d/&apos;$APP stop &gt; uninstall.sh
    echo &apos;sudo rm /etc/init.d/&apos;$APP &gt;&gt; uninstall.sh
    echo &apos;sudo rm /etc/rc1.d/&apos;$RL1 &gt;&gt; uninstall.sh
    echo &apos;sudo rm /etc/rc2.d/&apos;$RL2 &gt;&gt; uninstall.sh
    echo &apos;sudo rm /etc/rc3.d/&apos;$RL3 &gt;&gt; uninstall.sh
    echo &apos;sudo rm /etc/rc4.d/&apos;$RL4 &gt;&gt; uninstall.sh
    echo &apos;sudo rm /etc/rc5.d/&apos;$RL5 &gt;&gt; uninstall.sh
    echo &apos;sudo rm /etc/rc6.d/&apos;$RL6 &gt;&gt; uninstall.sh
    echo &apos;sudo rm -rf &apos;$FULLPATH &gt;&gt; uninstall.sh

    BINDIR=$FULLPATH/erts-$ERTS_VSN/bin
    EMU=beam
# need to escape full path before substitution
    ESC_PATH=`(echo $FULLPATH | sed &apos;s/\//\\\\\//g&apos;)`
    echo &apos;$ESC_PATH =&apos;$ESC_PATH

    DEST=erl;sed &quot;s/%FINAL_ROOTDIR%/$ESC_PATH/&quot;  $BINDIR/$DEST.src &gt; $BINDIR/$DEST
    DEST=start;sed &quot;s/%FINAL_ROOTDIR%/$ESC_PATH/&quot;  $BINDIR/$DEST.src &gt; $BINDIR/$DEST
    DEST=start_erl;sed &quot;s/%FINAL_ROOTDIR%/$ESC_PATH/&quot;  $BINDIR/$DEST.src &gt; $BINDIR/$DEST
    DEST=website;
       sed &quot;s/%FINAL_ROOTDIR%/$ESC_PATH/&quot;  installer/$DEST.src | 
       sed &quot;s/%USER%/$USER/&quot; |
       sed &quot;s/%APP%/$APP/&quot; &gt; installer/$DEST

    chmod +x $APP/bin/$APP*
    chmod +x $BINDIR/*
    chmod +x installer/website

    sudo cp installer/website /etc/init.d
    sudo ln -s /etc/init.d/website /etc/rc1.d/$RL1 
    sudo ln -s /etc/init.d/website /etc/rc2.d/$RL2 
    sudo ln -s /etc/init.d/website /etc/rc1.d/$RL3 
    sudo ln -s /etc/init.d/website /etc/rc2.d/$RL4 
    sudo ln -s /etc/init.d/website /etc/rc1.d/$RL5 
    sudo ln -s /etc/init.d/website /etc/rc2.d/$RL6 

    sudo /etc/init.d/$APP start

fi
</pre> </pre>
  <h4 >Building for a different system</h4>
<h3 >Running the build in a test environment</h3>
  <h4 >Testing from a non-graphic build machine</h4>
<h3 >Running the installer</h3>  
</content>
</page>
    <page >
  <name >FutureDev</name>
  <title >Future Developments</title>
  <url >futuredev.html</url>
  <keywords ></keywords>
  <pageheader ></pageheader>
  <file_headers >&lt;!DOCTYPE html&gt;</file_headers>
<content >
<p >
This page represents a snapshot of intentions at the time
of publishing.  It is subject to revision without notice.
</p>
<h4 >Unordered list of unscheduled tasks</h4>
<ul >
<li >Build dynamic site for Peter&apos;s Videos</li>
<li >Login protected private pages</li>
<li >Data storage and retrieval for web pages</li>
<li >Remote administration</li>
<li >Source code control</li>
<li >Dynamic content websites</li>
</ul>
<h4 >Programme</h4>
<ol >
<li >Disable lid switch on Eee-PC</li>
<li >Tidy up this documentation</li>
<li >Preliminary design for web data storage and retrieval</li>
<li >Implement sourcecode control</li>
<li >Develop release v1.01</li>
</ol>
<h4 >Develop with next release v1.01</h4>
<ul >
<li >No-compile site configuration</li>
<li >Stylesheets part of site definition xml document</li>
<li >Improved graphic for tony.gen.nz</li>
</ul>
</content>
</page>
    <page >
  <name >REST Resources</name>
  <title >REST Resources</title>
  <url >rest.html</url>
  <keywords >REST</keywords>
  <pageheader ></pageheader>
  <file_headers ></file_headers>
  <content >
<h3 >Rest is a stateless protocol for storing/retrieving data using HTTP</h3>
<p >The following resource classes have been defined for this purpose:</p>
<ul >
  <li ><em >static/[id]</em> denotes a resource that will never change.  Such resources may be versions of a symbolic resource</li>
  <li ><em >symbolic/[id]</em> denotes a reference to something that changes.  When used with GET retrieves the latest version of the resource.  When used with PUT or POST causes the creation of a new static resource with the contained data.</li>
  <li ><em >symbolic/[id];ts=[timestamp]</em>For GET retrieves the static resource that was current at time ts.  For PUT, or POST a static resource with a creation stamp as given by ts is created.</li>  
  <li ><em >collection;ts=[timestamp];filter=[filterexpr]</em> denotes a set of static resources that existed at ts and for which filter is true.  Valid for GET.</li>
  <li ><em >checkpointed</em> Checkpointed resources are saved state from
a particular point in time that have an external value.  For example a
statement of account, once posted to a client should be saved.  Similarly
stocktake counts are fixed references in time.</li>
  <li ><em >calculate</em> These resources imply a specific processing function over the data.</li>
</ul>
<p >Id values for static and symbolic resources are globally unique.</p>
<p >In this document the state of something represents the totality
of all of its components.  The state of a system is all the data that
is contained in that system.  So when transactions are applied to a
system its state changes.</p>
<p >The state of a symbolic resource can therefore be thought of as
changing though time by the application of static resources.  The state
of that symbolic resource is therefore equal to the value of the
last static resource with a timestamp less than or equal to the
symbolic resources timestamp.  It is important that the data retrieval
mechanism be able to evaluate this quantity efficiently.</p>
<h3 >Issues</h3>
<ul >
  <li ><em >Rest security.</em> By definition REST is a stateless protocol.  Session cookies and other security mechanisms imply the existence of state.  One possible mechanism is to require clients to encrypt data with their private key so that each transmission can be properly validated.  Is this supported by browsers?</li>
</ul>
  </content>
</page>
  </pages>
  <pages >
    <homepage >index.xhtml</homepage>
    <navtype >mesh</navtype>
    <contact-phone >Phone: 027 2203796</contact-phone>
    <contact-email ><a  href="mailto:tony@tony.gen.nz">Email: tony@tony.gen.nz</a></contact-email>
    <banner_image ><img  width="100%" left="250px" src="images/hw.png"></img></banner_image>
    <page  xmlns:ax="abc" xmlns:xi="http://www.w3.org/2001/XInclude">
  <name >Add_Website</name>
  <title >Add_Website</title>
  <url >addwebsite.xhtml</url>
  <keywords >xml</keywords>
  <pageheader >Greenrose</pageheader>
<ax:content  xmlns:xh="http://www.w3.org/1999/xhtml">
<p >
ERRATA: Site rules need to be compiled and put into ebin directory
as part of build procedure.  This is not currently part of make rules
</p>

<h1 >Add Website</h1>
<p >All code in this section is written in Erlang.  The webserver is cowboy.
This page is not intended as a tutorial for either of these, rather
it is intended to explain how to update the Cowboy webserver as used here.</p>
<p >Edit the src/start.erl program and add the url along with the name of the
configuration program.  The current start.erl is shown here for instruction.
</p>
<pre>-module(start).
-export([main/1,go/0,start/0,stop/0,load/0]).
%% TODO: go works, start works stop does not.  Why?
%% {&quot;greenrose.co.nz&quot;,greenroseconfig}
-define(APP,website).
-define(SUP,website_sup).

main(_) -&gt;
    go().

load() -&gt;
    application:load(?APP),
    application:start(sasl),
    application:start(crypto),
    application:start(ranch),
    application:start(cowlib),
    application:start(cowboy).
    %% in the test environment mnesia is memory resident so tables need to be set up
go() -&gt;
    load(),
    start().

start() -&gt;
    application:start(?APP).
    %mnesia_procs:do_once().
stop() -&gt;
    application:stop(?APP).



</pre>
<p >
The configuration programs are stored siteconf directory.  The purposes
of the siteconf programs are twofold:</p>
<ul >
  <li >To separate each site&apos;s configuration into a single file pertaining to that site for better code modularity,</li>
  <li >To define handlers mapping URL&apos;s to handlers for that type of resource.</li>
</ul>
<p >The handler for this site (which is currently static files only) is shown below.</p>
<pre>-module(tonygenconfig).

-export([routing/2]).

routing(SiteName,DataDir) -&gt;
    ExtSite = lists:append([&quot;[...]&quot;,SiteName]),
    IdxFile = filename:join(DataDir,&quot;tonygen/web_root/index.html&quot;),
    StaticDir = filename:join(DataDir,&quot;tonygen/web_root&quot;),
    true = filelib:is_regular(IdxFile),
    true = filelib:is_dir(StaticDir),
    {ExtSite,
	[
	 {&quot;/&quot;, ajw_cowboy_static, {file, IdxFile}},
	 {&quot;/[...]&quot;, ajw_cowboy_static, {dir, StaticDir}}
	]
    }.
</pre>
<p >The data files need to be copied into the resource directory which is clients/&lt;site_identifier&gt;/webroot/  If this directory does not exist for your site it needs to be made.  The site_identifier must match the path in the site configuration file.  In this case &quot;tonygen&quot;</p>
<p >Now the site needs to be compiled and tested.  Compiling is done by running the command erl -make.</p>
<p >Start the website by running erl and then executing start:go in the development web server&apos;s source directory.  If everything is right it should start okay.</p>
<p >Next put an entry into the hosts file &quot;/etc/hosts&quot; to point back to the localhost.  What is done here is to make this a test host as in test.tony.gen.nz 127.0.0.1.  The easiest way to do this is to copy the /etc/hosts to the local directory, edit it there, and copy it back.</p>
<p >Now the website should show in the test webserver</p>
<h2 >Deployment</h2>
<p >The test site has been tested, not the task is to go live.  For a new
website the DNS A record must be changed so that the site can be accessed
by the public.  This is done through your Domain Name supplier&apos;s website.</p>
<p >Next an erlang runtime build needs to be generated and deployed.</p>
<p >Building is done with relx by Ninenines.</p>
<p >From here my knowledge gets a bit thin, I will update this section
as I learn more about using tar.gz to install a update.  This will
be necessary when updating the production server.</p>
<p >Prepare server by assigning static-ip in /etc/network/interfaces.
Disable lid switch in /etc/systemd/logind if installing on laptop.</p>

<h2 >Including Static Pages Into the Build</h2>
The build process outlined above relies on <em >make</em>.  The process is as follows:
<ol >
  <li >Build the static site</li>
  <li >Copy the pages to the client directory of the website support directory</li>
  <li >Update the release version.  This is in relx.config.  There is some way of using overlays to do this in relx, but I don&apos;t know how to do it yet.</li>
  <li >Make the release directory structure by running &quot;make&quot; in the support directory</li>
  <li >Copy the static pages into release directory by running &quot;make static-pages in the support directory</li>
  <li >Make a release by compressing release directory. The release directory is the subdirectory containing the &quot;lib&quot; directory.</li>
</ol>
</ax:content>
</page>
    <page  xmlns:ax="abc" xmlns:xi="http://www.w3.org/2001/XInclude">
  <name >Admin_todo</name>
  <title >Admin_todo</title>
  <url >admin_todod.xhtml</url>
  <keywords >xml</keywords>
  <pageheader >Greenrose</pageheader>
<ax:content  xmlns="http://www.w3.org/1999/xhtml">
<ul >
<li >Understand sysadmin procedures for erlang applications
that include mnesia databases.  Incorporate these into these
web administration pages.</li>
<li >Download a relx manual from ninenines</li>
<li >Understand relx overlays</li>
</ul>
</ax:content>
</page>
    <page  xmlns:ax="abc" xmlns:xi="http://www.w3.org/2001/XInclude">
  <name >Admin_troubleshooting</name>
  <title >Troubleshooting</title>
  <url >admin_troubleshooting.html</url>
  <keywords >xml</keywords>
  <pageheader >Greenrose</pageheader>
<ax:content  xmlns:xh="http://www.w3.org/1999/xhtml">
<ul >
<symptom >Built system not working correctly</symptom>
<possible_cause >Conflict between multiple installed copies</possible_cause>
<corrective_actions >
<ol >
<li >Remove all copies from usr/lib/erlang and usr/local/erlang</li>
<li >Reinstall with make install from latest version</li>
</ol>
</corrective_actions>
<symptom >Laptop suspends when lid closed (not good when using laptop as server)</symptom>
<possible_cause >Lid switch not ignored in /etc/systemd/logind.conf</possible_cause>
<corrective_actions >
Set entry HandleLidSwitch to ignore in /etc/systemd/logind.conf
</corrective_actions>
</ul>
</ax:content>
</page>
  </pages>
</site>