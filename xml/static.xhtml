<?xml version="1.0"?><!DOCTYPE html><xhtml:html ><xhtml:head ><xhtml:meta  content="xml" name="Keywords"></xhtml:meta><xhtml:title >static site</xhtml:title><xhtml:meta  content="width=device-width, initial-scale=1" name="viewport"></xhtml:meta><xhtml:style  type="text/css">
  body {color:blue;}  
  p  {line-height=130%;}
  h1 {text-align:center;}
  h2 {text-align:center;}
  h3 {text-align:center;}
  pre { color:#800080;}
  a:link {color:#0000FF;}
  a:visited {color:#C0C000;}
  nav {
  background-image:url(images/grgcleft2.png);
  position: absolute;
  top :0px;
  bottom:0;
  left: 0;
  width: 240px;
}
  section {
  position: relative;
  margin-left: 250px;
}
</xhtml:style></xhtml:head><xhtml:body ><xhtml:nav ><xhtml:h2 >Contact</xhtml:h2><xhtml:ul ><xhtml:li >Phone: 027 2203796</xhtml:li><xhtml:li ><xhtml:a  xmlns:xf="http://www.w3.org/2002/xforms" xmlns:xi="http://www.w3.org/2001/XInclude" href="mailto:tony@tony.gen.nz">Email: tony@tony.gen.nz</xhtml:a></xhtml:li><xhtml:li ><xhtml:a  href="index.xhtml">Home Page</xhtml:a></xhtml:li><xhtml:li ><xhtml:a  href="intro.xhtml">intro</xhtml:a></xhtml:li><xhtml:li ><xhtml:a  href="whatsxml.xhtml">whatsxml</xhtml:a></xhtml:li><xhtml:li ><xhtml:a  href="xmlproc.xhtml">Xml processing</xhtml:a></xhtml:li><xhtml:li ><xhtml:a  href="namespaces.xhtml">namespaces</xhtml:a></xhtml:li><xhtml:li ><xhtml:a  href="xpath.xhtml">xpath</xhtml:a></xhtml:li><xhtml:li ><xhtml:a  href="xslt.xhtml">xslt</xhtml:a></xhtml:li><xhtml:li ><xhtml:a  href="static.xhtml">static site</xhtml:a></xhtml:li><xhtml:li ><xhtml:a  href="validation.xhtml">Validation</xhtml:a></xhtml:li><xhtml:li ><xhtml:a  href="splitpages.xhtml">split_pages</xhtml:a></xhtml:li><xhtml:li ><xhtml:a  href="insert.xhtml">insert_content</xhtml:a></xhtml:li><xhtml:li ><xhtml:a  href="build.xhtml">build</xhtml:a></xhtml:li><xhtml:li ><xhtml:a  href="futuredev.xhtml">FutureDev</xhtml:a></xhtml:li><xhtml:li ><xhtml:a  href="rest.xhtml">REST Resources</xhtml:a></xhtml:li><xhtml:li ><xhtml:a  href="upload_video.xhtml">video</xhtml:a></xhtml:li></xhtml:ul></xhtml:nav><xhtml:section ><xhtml:a  href="index.xhtml"><xhtml:img  xmlns:xf="http://www.w3.org/2002/xforms" xmlns:xi="http://www.w3.org/2001/XInclude" src="images/hw.png" left="250px" width="100%"></xhtml:img></xhtml:a><xhtml:br ></xhtml:br><xhtml:h2  xmlns:xf="http://www.w3.org/2002/xforms" xmlns:xi="http://www.w3.org/2001/XInclude">Why  build a site this way?</xhtml:h2><xhtml:p  xmlns:xf="http://www.w3.org/2002/xforms" xmlns:xi="http://www.w3.org/2001/XInclude">In this lesson we will build a site with static content
using the tools we have learnt thus far.  Why do it this way?
A website can be viewed as an organised collection of pages. 
Editing pages on an adhoc basis can lead to inconsistency
between pages.  This is partially overcome using shared css 
stylesheets, however this does not model the relationship 
between the pages.  Xml can model the relationship between
the web pages, be they nested or disjoint sets.</xhtml:p><xhtml:p  xmlns:xf="http://www.w3.org/2002/xforms" xmlns:xi="http://www.w3.org/2001/XInclude">XSLT has been chosen as a templating tool (in preference
to more modern and widely accepted standards such as django) because
it is part of multimedia tool kitsnthat allow the production
of other media formats such as pdf.  This is important in connection
with publishing as I am also a director for a publishing company.  I
had intended to style with XSL-FO in preference for CSS for the same
reason but at the time I built this site I deferred XSL-FO as
I had enough to learn at the time, and figured it could be
retrofitted relatively easily.</xhtml:p><xhtml:h2  xmlns:xf="http://www.w3.org/2002/xforms" xmlns:xi="http://www.w3.org/2001/XInclude">This site master file: pagedata.xml</xhtml:h2><xhtml:pre  xmlns:xf="http://www.w3.org/2002/xforms" xmlns:xi="http://www.w3.org/2001/XInclude"><pre >&lt;!--
File:    pagedata.xml
Author:  Tony Wallace
Purpose: Website definition file 
--&gt;
&lt;site xmlns:xf=&quot;http://www.w3.org/2002/xforms&quot;
xmlns:xi=&quot;http://www.w3.org/2001/XInclude&quot;
xmlns:xhtml=&quot;http://www.w3.org/1999/xhtml&quot;&gt;
  &lt;siteurl&gt;www.tony.gen.nz/xml&lt;/siteurl&gt;
  &lt;html_dir&gt;html&lt;/html_dir&gt;
  &lt;resources&gt;
    &lt;copydir&gt;html&lt;/copydir&gt;
  &lt;/resources&gt;
  &lt;file_headers&gt;&lt;![CDATA[&lt;?xml version=&quot;1.0&quot;?&gt;&lt;!DOCTYPE html&gt;]]&gt;&lt;/file_headers&gt;
  &lt;pages&gt;
    &lt;homepage&gt;index.xhtml&lt;/homepage&gt;
    &lt;navtype&gt;mesh&lt;/navtype&gt;
    &lt;contact-phone&gt;Phone: 027 2203796&lt;/contact-phone&gt;
    &lt;contact-email&gt;&lt;xhtml:a href=&quot;mailto:tony@tony.gen.nz&quot;&gt;Email: tony@tony.gen.nz&lt;/xhtml:a&gt;&lt;/contact-email&gt;
    &lt;banner_image&gt;&lt;xhtml:img src=&quot;images/hw.png&quot; left=&quot;250px&quot; width=&quot;100%&quot; /&gt;&lt;/banner_image&gt;
    &lt;xi:include href=&quot;index.xml&quot; parse=&quot;xml&quot;/&gt;
  &lt;/pages&gt;
  &lt;pages&gt;
    &lt;homepage&gt;index.xhtml&lt;/homepage&gt;
    &lt;navtype&gt;mesh&lt;/navtype&gt;
    &lt;contact-phone&gt;Phone: 027 2203796&lt;/contact-phone&gt;
    &lt;contact-email&gt;&lt;xhtml:a href=&quot;mailto:tony@tony.gen.nz&quot;&gt;Email: tony@tony.gen.nz&lt;/xhtml:a&gt;&lt;/contact-email&gt;
    &lt;banner_image&gt;&lt;xhtml:img src=&quot;images/hw.png&quot; left=&quot;250px&quot; width=&quot;100%&quot; /&gt;&lt;/banner_image&gt;
    &lt;xi:include href=&quot;intro.xml&quot; parse=&quot;xml&quot;/&gt;
    &lt;xi:include href=&quot;whatsxml.xml&quot; parse=&quot;xml&quot;/&gt;
    &lt;xi:include href=&quot;xmlprocessing.xml&quot; parse=&quot;xml&quot;/&gt;
    &lt;xi:include href=&quot;namespaces.xml&quot;  parse=&quot;xml&quot;/&gt;
    &lt;xi:include href=&quot;xpath.xml&quot;  parse=&quot;xml&quot;/&gt;
    &lt;xi:include href=&quot;xslt.xml&quot; parse=&quot;xml&quot;/&gt;
    &lt;xi:include href=&quot;staticsite.xml&quot; parse=&quot;xml&quot;/&gt;
    &lt;xi:include href=&quot;validation.xml&quot; parse=&quot;xml&quot;/&gt;
    &lt;xi:include href=&quot;splitpages.xml&quot; parse=&quot;xml&quot; /&gt;
    &lt;xi:include href=&quot;inserting_content.xml&quot; parse=&quot;xml&quot; /&gt;
    &lt;xi:include href=&quot;build.xml&quot; parse=&quot;xml&quot; /&gt;
    &lt;xi:include href=&quot;future_development.xml&quot; parse=&quot;xml&quot; /&gt;
    &lt;xi:include href=&quot;rest.xml&quot; parse=&quot;xml&quot; /&gt;
    &lt;xi:include href=&quot;video.xml&quot; parse=&quot;xml&quot; /&gt;
  &lt;/pages&gt;
  &lt;pages&gt;
    &lt;homepage&gt;index.xhtml&lt;/homepage&gt;
    &lt;navtype&gt;mesh&lt;/navtype&gt;
    &lt;contact-phone&gt;Phone: 027 2203796&lt;/contact-phone&gt;
    &lt;contact-email&gt;&lt;xhtml:a href=&quot;mailto:tony@tony.gen.nz&quot;&gt;Email: tony@tony.gen.nz&lt;/xhtml:a&gt;&lt;/contact-email&gt;
    &lt;banner_image&gt;&lt;img src=&quot;images/hw.png&quot; left=&quot;250px&quot; width=&quot;100%&quot; /&gt;&lt;/banner_image&gt;
    &lt;xi:include href=&quot;publickey.xml&quot; parse=&quot;xml&quot; /&gt;
  &lt;/pages&gt;    
  &lt;pages&gt;
    &lt;homepage&gt;index.xhtml&lt;/homepage&gt;
    &lt;navtype&gt;mesh&lt;/navtype&gt;
    &lt;contact-phone&gt;Phone: 027 2203796&lt;/contact-phone&gt;
    &lt;contact-email&gt;&lt;xhtml:a href=&quot;mailto:tony@tony.gen.nz&quot;&gt;Email: tony@tony.gen.nz&lt;/xhtml:a&gt;&lt;/contact-email&gt;
    &lt;banner_image&gt;&lt;img src=&quot;images/hw.png&quot; left=&quot;250px&quot; width=&quot;100%&quot; /&gt;&lt;/banner_image&gt;
    &lt;xi:include href=&quot;addwebsite.xml&quot; parse=&quot;xml&quot; /&gt;
    &lt;xi:include href=&quot;admin_todo.xml&quot; parse=&quot;xml&quot; /&gt;
    &lt;xi:include href=&quot;admin_troubleshooting.xml&quot; parse=&quot;xml&quot; /&gt;
  &lt;/pages&gt;
&lt;/site&gt;
 
</pre></xhtml:pre><xhtml:h2  xmlns:xf="http://www.w3.org/2002/xforms" xmlns:xi="http://www.w3.org/2001/XInclude">This page definition</xhtml:h2><xhtml:p  xmlns:xf="http://www.w3.org/2002/xforms" xmlns:xi="http://www.w3.org/2001/XInclude">This is the definition for this page.  Everything about this
page, its name, its url and all other things required for its
generation are stored here...</xhtml:p><xhtml:h2  xmlns:xf="http://www.w3.org/2002/xforms" xmlns:xi="http://www.w3.org/2001/XInclude">staticsite.xml</xhtml:h2><xhtml:pre  xmlns:xf="http://www.w3.org/2002/xforms" xmlns:xi="http://www.w3.org/2001/XInclude"><pre >&lt;!--
File:     staticsite.xml
Author:   Tony Wallace
Purpose:  Document how static sites are generated by this software
Usage:    This is a topic which becomes a single page in the website.
          This file is intended to be imported into pagedata.xml as
	  part of the site production process.
Notes:    As this file is intended for inclusion into another xml document
          it does not have an xml directive.

--&gt;
&lt;page 
    xmlns:xhtml=&quot;http://www.w3.org/1999/xhtml&quot;  
    xmlns:ax=&quot;abc&quot; 
    xmlns:xi=&quot;http://www.w3.org/2001/XInclude&quot;
    schema=&quot;site.rnc&quot;&gt;
&lt;name &gt;static site&lt;/name&gt;
&lt;title &gt;static site&lt;/title&gt;
&lt;url &gt;static.xhtml&lt;/url&gt;
&lt;keywords &gt;xml&lt;/keywords&gt;
&lt;pageheader &gt;Greenrose&lt;/pageheader&gt;
&lt;ax:content xmlns:ax=&quot;abc&quot;&gt;
&lt;xhtml:h2&gt;Why  build a site this way?&lt;/xhtml:h2&gt;
&lt;xhtml:p&gt;In this lesson we will build a site with static content
using the tools we have learnt thus far.  Why do it this way?
A website can be viewed as an organised collection of pages. 
Editing pages on an adhoc basis can lead to inconsistency
between pages.  This is partially overcome using shared css 
stylesheets, however this does not model the relationship 
between the pages.  Xml can model the relationship between
the web pages, be they nested or disjoint sets.&lt;/xhtml:p&gt;
&lt;xhtml:p&gt;XSLT has been chosen as a templating tool (in preference
to more modern and widely accepted standards such as django) because
it is part of multimedia tool kitsnthat allow the production
of other media formats such as pdf.  This is important in connection
with publishing as I am also a director for a publishing company.  I
had intended to style with XSL-FO in preference for CSS for the same
reason but at the time I built this site I deferred XSL-FO as
I had enough to learn at the time, and figured it could be
retrofitted relatively easily.&lt;/xhtml:p&gt;
&lt;xhtml:h2 &gt;This site master file: pagedata.xml&lt;/xhtml:h2&gt;
&lt;xhtml:pre &gt;&lt;xi:include  parse=&quot;text&quot; href=&quot;pagedata.xml&quot;&gt;&lt;/xi:include&gt;&lt;/xhtml:pre&gt;
&lt;xhtml:h2&gt;This page definition&lt;/xhtml:h2&gt;

&lt;xhtml:p&gt;This is the definition for this page.  Everything about this
page, its name, its url and all other things required for its
generation are stored here...&lt;/xhtml:p&gt;
&lt;xhtml:h2 &gt;staticsite.xml&lt;/xhtml:h2&gt;
&lt;xhtml:pre&gt;&lt;xi:include href=&quot;staticsite.xml&quot; parse=&quot;text&quot;/&gt;&lt;/xhtml:pre&gt;

&lt;xhtml:h2 &gt;An XSLT utility file: ajw_utils.xsl&lt;/xhtml:h2&gt;
&lt;xhtml:p&gt;
This is one of two files for converting this site data into html.
&lt;/xhtml:p&gt;
&lt;xhtml:pre &gt;&lt;xi:include  parse=&quot;text&quot; href=&quot;ajw_utils.xsl&quot;&gt;&lt;/xi:include&gt;&lt;/xhtml:pre&gt;&lt;xhtml:h2 &gt;XSLT file to generate HTML&lt;/xhtml:h2&gt;
&lt;xhtml:p&gt;
This file, &lt;xhtml:em&gt;make_web.xsl&lt;/xhtml:em&gt; generates each web page including navigation bar.
&lt;/xhtml:p&gt;
&lt;xhtml:pre&gt;
&lt;xi:include  href=&quot;make_web.xsl&quot; parse=&quot;text&quot;&gt;&lt;/xi:include&gt;
&lt;/xhtml:pre&gt;
&lt;xhtml:h2&gt;Extra functionality from a SAX parser&lt;/xhtml:h2&gt;
&lt;xhtml:p&gt;During construction it was found that the xmllint
xinclude did not work properly with the parse=&quot;text&quot; attribute.
It was also required to find a way to split up the site into
separate html pages and to store and save into these pages
processing instructions.&lt;/xhtml:p&gt;
&lt;xhtml:p&gt;These functions were built using the erlsom SAX parser
and custom erlang programming.  The disadvantage of going
to SAX and erlang compared to using XSLT is obvious, the
program is much longer. However the advantage is that
using a general purpose language like erlang allows complete
flexibility.&lt;/xhtml:p&gt;  
&lt;xhtml:p&gt;Finally, there is a significant amount of code dedicated
to self testing.&lt;/xhtml:p&gt;
&lt;xhtml:p&gt;This code is shown here.  &lt;xhtml:em&gt;xslt_extn.erl&lt;/xhtml:em&gt;&lt;/xhtml:p&gt;
&lt;xhtml:pre&gt;
&lt;xi:include href=&quot;../src/xslt_extn.erl&quot; parse=&quot;text&quot; /&gt;
&lt;/xhtml:pre&gt;
&lt;xhtml:h2 &gt;A build script to put it all together&lt;/xhtml:h2&gt;
&lt;xhtml:pre &gt;
&lt;![CDATA[
cd site_data
escript ../ebin/xslt_extn.beam &lt; pagedata.xml &gt; fullsite.xml 2&gt; errors.txt
xsltproc ../src/make_web2.xsl fullsite.xml &gt; allpages.xml
escript ../ebin/xslt_extn.beam +finaloutput &lt; allpages.xml 
mv *.html ../html
]]&gt;
&lt;/xhtml:pre&gt;
&lt;xhtml:p&gt;The first call to xslt_extn includes all the page
definitions in pagedata.xml creating the file fillsite.xml.
This data is then put through xslt processing to form a
new file allpages.xml.  This file has all the webpages
properly laid out, but all in a single file.  xslt_extn
is called again to split these files and output the
processing instructions into the web pages.  Finally
these html web pages are copied to the websites html directory.
&lt;/xhtml:p&gt;
&lt;/ax:content&gt;&lt;/page&gt;
</pre></xhtml:pre><xhtml:h2  xmlns:xf="http://www.w3.org/2002/xforms" xmlns:xi="http://www.w3.org/2001/XInclude">An XSLT utility file: ajw_utils.xsl</xhtml:h2><xhtml:p  xmlns:xf="http://www.w3.org/2002/xforms" xmlns:xi="http://www.w3.org/2001/XInclude">
This is one of two files for converting this site data into html.
</xhtml:p><xhtml:pre  xmlns:xf="http://www.w3.org/2002/xforms" xmlns:xi="http://www.w3.org/2001/XInclude"><pre >&lt;!--
Author:  Tony Wallace
Contact: tony@tony.gen.nz

Licence: This program is donated to the public domain.
Freely I have received, freely I give.

I acknowledge the work of the w3 consortium that made
this work possible.
--&gt;
&lt;!--
A few xslt utilities..

The cdata tag encloses the result of apply templates
into a ddata tag with a the data quoted by CDATA tags.
A ddata maintains the CDATA tags through processing
steps and stops the CDATA tags from disappearing by
putting ddata into the output cdata-section-elements.
--&gt;
&lt;xsl:stylesheet
  xmlns:xsl=&quot;http://www.w3.org/1999/XSL/Transform&quot; version=&quot;1.0&quot;
  xmlns:ax=&quot;abc&quot;&gt;
  
&lt;xsl:output method = &quot;xml&quot;/&gt;
&lt;xsl:template match=&quot;/&quot;&gt;
  &lt;xsl:apply-templates/&gt;
&lt;/xsl:template&gt;

&lt;xsl:template match=&quot;@*&quot;&gt;
  &lt;xsl:attribute name=&quot;{name()}&quot;&gt;
    &lt;xsl:message&gt;create attribute &lt;xsl:value-of select=&quot;name()&quot;/&gt; = 
         &lt;xsl:value-of select=&quot;.&quot; /&gt; &lt;/xsl:message&gt;
    &lt;xsl:value-of select=&quot;.&quot;/&gt;
  &lt;/xsl:attribute&gt;
&lt;/xsl:template&gt;

&lt;xsl:template match=&quot;text()&quot;&gt;
  &lt;xsl:value-of select=&quot;.&quot;/&gt;
&lt;/xsl:template&gt;

&lt;xsl:template match=&quot;node()&quot;&gt;
  &lt;xsl:message&gt;general match &lt;xsl:value-of select=&quot;name()&quot;/&gt;&lt;/xsl:message&gt;
  &lt;xsl:element name=&quot;{name()}&quot;&gt;
    &lt;xsl:apply-templates/&gt;
  &lt;/xsl:element&gt;
&lt;/xsl:template&gt;

&lt;xsl:template match=&quot;text()&quot; name=&quot;insertBreaks&quot; mode=&quot;crtobr&quot;&gt;
  &lt;xsl:param name=&quot;pText&quot; select=&quot;.&quot;/&gt;

  &lt;xsl:choose&gt;
    &lt;xsl:when test=&quot;not(contains($pText, &apos;&amp;#xA;&apos;))&quot;&gt;
      &lt;xsl:copy-of select=&quot;$pText&quot;/&gt;
    &lt;/xsl:when&gt;
    &lt;xsl:otherwise&gt;
      &lt;xsl:value-of select=&quot;substring-before($pText, &apos;&amp;#xA;&apos;)&quot;/&gt;
      &lt;br /&gt;
      &lt;xsl:call-template name=&quot;insertBreaks&quot;&gt;
	&lt;xsl:with-param name=&quot;pText&quot; select=
	  &quot;substring-after($pText, &apos;&amp;#xA;&apos;)&quot;/&gt;
      &lt;/xsl:call-template&gt;
    &lt;/xsl:otherwise&gt;
  &lt;/xsl:choose&gt;
&lt;/xsl:template&gt;
&lt;/xsl:stylesheet&gt;
</pre></xhtml:pre><xhtml:h2  xmlns:xf="http://www.w3.org/2002/xforms" xmlns:xi="http://www.w3.org/2001/XInclude">XSLT file to generate HTML</xhtml:h2><xhtml:p  xmlns:xf="http://www.w3.org/2002/xforms" xmlns:xi="http://www.w3.org/2001/XInclude">
This file, <xhtml:em >make_web.xsl</xhtml:em> generates each web page including navigation bar.
</xhtml:p><xhtml:pre  xmlns:xf="http://www.w3.org/2002/xforms" xmlns:xi="http://www.w3.org/2001/XInclude">
<pre >&lt;?xml version=&quot;1.0&quot; encoding=&quot;ISO-8859-1&quot;?&gt;
&lt;!--
File:    make_web.xsl
Author:  Tony Wallace
Contact: tony@tony.gen.nz

Licence: This program is donated to the public domain.
Freely I have received, freely I give.

I acknowledge the work of the w3 consortium that made
this work possible.
--&gt;

&lt;!--
Note: xslt 1.0 cannot produce multiple output files
This is done by a file element in the &quot;abc&quot; namespace
which is processed by xslt_extn.

Processing instructions are surrounded by &lt;xml_tags&gt; element
in the &quot;abc&quot; namespace and stored in an escaped form, until
processed by xslt_extn with a +finaloutput option.
--&gt;

&lt;!--
Modification: 

Put filename into comment at top of file
so that it can appear in generated documentation.
--&gt;
&lt;!--
Modification:
  Generating page headers in output
  now searches ancestor-or-self axis.
  Site.rnc definition changed to allow file_headers
  element in site, pages, and page element.
Reason:
  File headers relatively standard across pages
  therefore allowing on an ancestor element allows
  simpler page editing.
  Use of ancestor axis allows customisation at
  any desired level, overriding the default posed
  at a higher level.
Date: 10 June 2015
Author: Tony Wallace
--&gt;
&lt;xsl:stylesheet xmlns:xsl=&quot;http://www.w3.org/1999/XSL/Transform&quot; 
		xmlns:ax=&quot;abc&quot; 
		xmlns:xhtml=&quot;http://www.w3.org/1999/xhtml&quot;
version=&quot;1.0&quot;&gt;

&lt;!--
  &lt;xsl:import href=&quot;ajw_utils.xsl&quot; /&gt;
--&gt;

  &lt;xsl:template match=&apos;/site&apos;&gt;
    &lt;xsl:comment&gt;Generated web pages&lt;/xsl:comment&gt;
    &lt;site_pages&gt;
    &lt;xsl:for-each select=&quot;./pages&quot;&gt;
      &lt;xsl:apply-templates/&gt;
    &lt;/xsl:for-each&gt;
    &lt;/site_pages&gt;
  &lt;/xsl:template&gt;


&lt;xsl:template match=&quot;pages&quot; name=&quot;pages-template&quot;&gt;
  &lt;xsl:for-each select=&quot;page&quot;&gt;
    &lt;xsl:apply-templates/&gt;
  &lt;/xsl:for-each&gt;
&lt;/xsl:template&gt;

&lt;xsl:template match=&quot;page&quot;&gt;
&lt;xsl:element name=&quot;ax:file&quot;&gt;
&lt;xsl:attribute name=&quot;filename&quot;&gt;
  &lt;xsl:value-of select=&quot;./url&quot; /&gt;
&lt;/xsl:attribute&gt;
&lt;xsl:message&gt;File &lt;xsl:value-of select=&quot;./url&quot; /&gt;&lt;/xsl:message&gt;
&lt;xsl:text xml:space=&quot;preserve&quot; &gt;
&lt;/xsl:text&gt;
&lt;ax:xml_tags&gt;
&lt;xsl:value-of select=&quot;ancestor-or-self::node()/file_headers&quot; /&gt;
&lt;/ax:xml_tags&gt;
&lt;xsl:element name=&quot;xhtml:html&quot; namespace=&quot;http://www.w3.org/1999/xhtml&quot;&gt;
&lt;xhtml:head&gt;
&lt;xhtml:meta name=&quot;Keywords&quot; content=&apos;{keywords}&apos; /&gt;
&lt;xhtml:title&gt;
  &lt;xsl:value-of select=&quot;./title&quot; /&gt;
&lt;/xhtml:title&gt;
&lt;xhtml:meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1&quot; /&gt;
&lt;xhtml:style type=&quot;text/css&quot;&gt;
  body {color:blue;}  
  p  {line-height=130%;}
  h1 {text-align:center;}
  h2 {text-align:center;}
  h3 {text-align:center;}
  pre { color:#800080;}
  a:link {color:#0000FF;}
  a:visited {color:#C0C000;}
  nav {
  background-image:url(images/grgcleft2.png);
  position: absolute;
  top :0px;
  bottom:0;
  left: 0;
  width: 240px;
}
  section {
  position: relative;
  margin-left: 250px;
}
&lt;/xhtml:style&gt;
  &lt;xsl:copy-of select=&quot;./model&quot; /&gt;

&lt;/xhtml:head&gt;
&lt;xhtml:body   xmlns:xhtml=&quot;http://www.w3.org/1999/xhtml&quot; &gt;
  &lt;xhtml:nav&gt;
  &lt;xhtml:h2&gt;Contact&lt;/xhtml:h2&gt;
  &lt;xhtml:ul&gt;
  &lt;xhtml:li&gt;&lt;xsl:value-of select=&quot;ancestor::pages/contact-phone&quot;/&gt;&lt;/xhtml:li&gt;
  &lt;xhtml:li&gt;&lt;xsl:copy-of  select=&quot;ancestor::pages/contact-email/*&quot;/&gt;&lt;/xhtml:li&gt;
  &lt;xhtml:li&gt;&lt;xhtml:a&gt;&lt;xsl:attribute name=&quot;href&quot;&gt;&lt;xsl:value-of select=&quot;ancestor::pages/homepage&quot;/&gt;&lt;/xsl:attribute&gt;Home Page&lt;/xhtml:a&gt;&lt;/xhtml:li&gt;
  &lt;xsl:choose&gt;
    &lt;xsl:when test=&quot;ancestor::pages[navtype=&apos;mesh&apos;]&quot;&gt;
      &lt;xsl:call-template name=&quot;meshindex&quot; /&gt;
    &lt;/xsl:when&gt;
    &lt;xsl:when test=&quot;ancestor::pages[navtype=&apos;linear&apos;]&quot;&gt;
      &lt;xsl:call-template name=&quot;linearindex&quot; /&gt;
    &lt;/xsl:when&gt;
    &lt;xsl:otherwise&gt;
      Failed to match index template:
      &lt;xsl:value-of select=&quot;ancestor::pages/navtype&quot;/&gt; 
      Current node is:
      &lt;xsl:value-of select=&quot;string(./node())&quot; /&gt;
    &lt;/xsl:otherwise&gt;
  &lt;/xsl:choose&gt;
  &lt;/xhtml:ul&gt;
&lt;/xhtml:nav&gt; 
&lt;xhtml:section&gt;
  &lt;xsl:message&gt;section&lt;/xsl:message&gt;
  &lt;xhtml:a&gt;
    &lt;xsl:attribute name=&quot;href&quot;&gt;
      &lt;xsl:value-of select=&quot;ancestor::pages/homepage&quot;/&gt;
    &lt;/xsl:attribute&gt;
    &lt;xsl:copy-of select=&quot;ancestor::pages/banner_image/child::xhtml:img&quot;/&gt;
  &lt;/xhtml:a&gt;
  &lt;xhtml:br /&gt;
  &lt;xsl:copy-of select=&quot;./ax:content/*&quot;/&gt;
&lt;/xhtml:section&gt;
&lt;/xhtml:body&gt;
&lt;/xsl:element&gt;
&lt;/xsl:element&gt;
&lt;/xsl:template&gt;

&lt;xsl:template name=&quot;meshindex&quot;&gt;
    &lt;xsl:for-each select=&quot;ancestor::pages/page&quot;&gt;
      &lt;xhtml:li&gt;
	&lt;xhtml:a&gt;
	&lt;xsl:attribute name=&quot;href&quot;&gt;
	  &lt;xsl:value-of select=&quot;.//url&quot;  /&gt;
	&lt;/xsl:attribute&gt;
	&lt;xsl:value-of select=&quot;.//name&quot; /&gt;
	&lt;/xhtml:a&gt;
      &lt;/xhtml:li&gt;
    &lt;/xsl:for-each&gt;
&lt;/xsl:template&gt;

&lt;xsl:template name=&quot;linearindex&quot;&gt;
    Mesh linear index
    &lt;a href=&quot;{(ancestor::pages)[1]/page[1]/url}&quot;&gt;Home&lt;/a&gt;
    &lt;a href=&quot;{ancestor::pages/page[1]}&quot;&gt;Start&lt;/a&gt;
    &lt;a href=&quot;{ancestor::page/preceding-sibling::page[1]/url}&quot;&gt;Previous&lt;/a&gt;
    &lt;a href=&quot;{ancestor::page/following-sibling::page[1]/url}&quot;&gt;Next&lt;/a&gt;
&lt;/xsl:template&gt;


&lt;/xsl:stylesheet&gt;
</pre>
</xhtml:pre><xhtml:h2  xmlns:xf="http://www.w3.org/2002/xforms" xmlns:xi="http://www.w3.org/2001/XInclude">Extra functionality from a SAX parser</xhtml:h2><xhtml:p  xmlns:xf="http://www.w3.org/2002/xforms" xmlns:xi="http://www.w3.org/2001/XInclude">During construction it was found that the xmllint
xinclude did not work properly with the parse=&quot;text&quot; attribute.
It was also required to find a way to split up the site into
separate html pages and to store and save into these pages
processing instructions.</xhtml:p><xhtml:p  xmlns:xf="http://www.w3.org/2002/xforms" xmlns:xi="http://www.w3.org/2001/XInclude">These functions were built using the erlsom SAX parser
and custom erlang programming.  The disadvantage of going
to SAX and erlang compared to using XSLT is obvious, the
program is much longer. However the advantage is that
using a general purpose language like erlang allows complete
flexibility.</xhtml:p><xhtml:p  xmlns:xf="http://www.w3.org/2002/xforms" xmlns:xi="http://www.w3.org/2001/XInclude">Finally, there is a significant amount of code dedicated
to self testing.</xhtml:p><xhtml:p  xmlns:xf="http://www.w3.org/2002/xforms" xmlns:xi="http://www.w3.org/2001/XInclude">This code is shown here.  <xhtml:em >xslt_extn.erl</xhtml:em></xhtml:p><xhtml:pre  xmlns:xf="http://www.w3.org/2002/xforms" xmlns:xi="http://www.w3.org/2001/XInclude">
<pre >-module(xslt_extn).
-author(&quot;Tony Wallace&quot;).
-email(&quot;tony@tony.gen.nz&quot;).
-licence(&quot;Public Domain&quot;).
-purpose(
&lt;&lt;&quot;
An erlang module to provide:
xinclude text file inclusion
Splitting an xml file into several target files
(like opposite of file inclusion)
xml_text - this tag allows xml to be stored as escaped text
and expanded again when \&quot;final-output\&quot; is performed

Limitations:
The xinclude functionality provided here does not conform to the
standard in that many options provided for in the standard are ignored.
&quot;&gt;&gt;).
%
% Licence: This program is donated to the public domain.
% Freely I have received, freely I give.
%
% I acknowledge the work of the Ericsson Laboratories,
% the creators of erlang, that made this work possible.
%%

%% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Modification:
%%  Copy inscope namespaces to first element after a &quot;file&quot; element.
%%  This is a consequence of the way XSLT 1.0 handles 
%%  namespaces, and the requirement
%%  to split this output into several files.
%% Author: Tony Wallace
%% Date: 10 June 2015
%% ****************************************************


-export([main/1,doevent/2,file/1]).
-export([test/0,test1/0,test2/0,test3/0,test4/0,test5/0,test6/0,
	 test7/0,test8/0,test9/0,test10/0]).
-include (&quot;erlsom_sax.hrl&quot;).
-record(startElement, {url,tag,prefix,attrlist}).
-record(endElement,{url,tag,prefix}).


%% debugging is provided if the debug_flag is compiled in.
%% from command line use: erlc -Ddebug_flag xslt_extn
%% in the erlang shell use: c(xslt_extn, {d,debug_flag}).
%% in rebar.config add the entry: {erl_opts,[{d,debug_flag}]}.

-ifdef(debug_flag).
-define (DEBUG(X), 
	 io:format(standard_error,
		   &quot;&lt;DEBUG module=\&quot;~p\&quot;~n line=\&quot;~p\&quot;~n timestamp=\&quot;~p\&quot;&gt;~n&lt;![CDATA[~p]]&gt;&lt;/DEBUG&gt;~n&quot;,
		   [?MODULE,?LINE,notime,X])).
-define (DEBUGSTR(X), 
	 io:format(standard_error,
		   &quot;&lt;DEBUG module=\&quot;~p\&quot;~n line=\&quot;~p\&quot;~n timestamp=\&quot;~p\&quot;&gt;~n&lt;![CDATA[~s]]&gt;&lt;/DEBUG&gt;~n&quot;,
		   [?MODULE,?LINE,notime,X])).

-define (DEBUG2(Msg,X), 
	 io:format(standard_error,
		   &quot;~s = ~p~n&quot;,
		   [Msg,X])).

-else.
-define (DEBUG(X), void).
-define (DEBUGSTR(X), void).
-define (DEBUG2(Msg,X), void).
-endif.
-define (PRESERVE_WHITESPACE_DEFAULT,true).
-define (FINAL_OUTPUT_DEFAULT,false).
-define (DATA_DIR,&quot;.&quot;).
-define (MUST_MATCH,&quot;~s ~s must match ~s ~s&quot;).
default_state() -&gt;
       #{default_output =&gt; standard_io,
   	output =&gt; standard_io, 
	fileinclusions =&gt; ordsets:new(),
	tests =&gt; [],
	escape_to_xml =&gt; false,
	final_output =&gt; ?FINAL_OUTPUT_DEFAULT,
	preserve_whitespace =&gt; ?PRESERVE_WHITESPACE_DEFAULT,
	element_stack =&gt; [],
	output_namespaces =&gt; false,
	names_in_scope =&gt; []}.    

main(InputParameters) -&gt; 
    ?DEBUG([&quot;input parameters&quot;|InputParameters]),
    State0 = default_state(),
    State1 = lists:foldl(fun do_param/2,State0,InputParameters),
    %% discard output until first output file statement
    {ok,TestList} = maps:find(tests,State1),
    case TestList == [] of
	true -&gt;
	    file:set_cwd(?DATA_DIR),
	    ?DEBUGSTR(&quot;Reading standard input until eof&quot;),
	    Str=lists:flatten(read_stdin:read_until_eof()),
	    ?DEBUGSTR(&quot;Outputting results&quot;),
	    parseStr(Str,State1);
	false -&gt;
	    ?DEBUG(TestList),
	    [do_test(T) || T &lt;- TestList]
    end,
    ?DEBUGSTR(&quot;Finished&quot;),
    init:stop().

file([Filename]) -&gt;
    file([Filename,[]]);
file([Filename,InputParameters]) -&gt;
    %% Purpose: to parse input from a file instead of stdin for testing purposes in erlang shell
    Dirname = filename:dirname(Filename),
    SavedDirName = filename:absname(&quot;.&quot;),
    State0 = default_state(),
    State1 = lists:foldl(fun do_param/2,State0,InputParameters),
    {ok,Str} = file:read_file(Filename),
    ok=file:set_cwd(Dirname), 
    parseStr(Str,State1),
    ok=file:set_cwd(SavedDirName).

do_param(&quot;+finaloutput&quot;,Si) -&gt;
    Si#{final_output =&gt; true};
do_param(&quot;-finaloutput&quot;,Si) -&gt;
    Si#{final_output =&gt; false};
do_param(&quot;+preserve_whitespace&quot;,Si) -&gt;
    Si#{preserve_whitespace =&gt; true};
do_param(&quot;-preserve_whitespace&quot;,Si) -&gt;
    Si#{preserve_whitespace =&gt; false};
do_param(T=[$t,$e,$s,$t|_],Si) -&gt;
    %% run tests...
    ?DEBUGSTR(&quot;Adding test to test list&quot;),
    ?DEBUG(T),
    {ok,OT} = maps:find(tests,Si),
    Si#{tests =&gt; [T|OT]};
do_param(Z,_) -&gt;
    throw(&quot;Unknown option &quot;++Z).


parseStr(Str,State) when is_list(Str),is_map(State) -&gt;
    State2=State#{skip_end_tag =&gt; false, prefix_next_tag=&gt; [] },
    erlsom:parse_sax(Str,State2,fun doevent/2).

%% Do event must comply with 
%% the PLI for erlsom:parse_sax
doevent(Event,State) when is_map(State) -&gt;
    ?DEBUG(Event),
    %% manage element stack
    Ctx = {S1,_ParentNS,_ParentTag,_Ancestors} =
	manage_element_stack(Event,State),
    true = is_map(S1),
    ?DEBUG2(&quot;S1&quot;,S1),
    R = do_evt_1(Event,Ctx),
    true = is_map(R),
    ?DEBUG(R),
    io:format(standard_error,&quot;~n&quot;,[]),
    R.

manage_element_stack(Event,State) when is_map(State) -&gt;
    {ok,ES} = maps:find(element_stack,State),
    {_S1,_ParentNS,_ParentTag,_Ancestors} = es_1(ES,Event,State).

es_1([],Event={startElement,_,_,_,_},State) -&gt;
    {State#{element_stack =&gt; [Event]},&quot;&quot;,&quot;&quot;,[]};
es_1([],{endElement,_,_,_,_},_) -&gt;
    throw(&quot;Closing tag without an opening tag&quot;);
es_1([],_,State) -&gt;
    io:format(standard_error,&quot;No change to element stack which is empty~n&quot;,[]),
    {State,&quot;&quot;,&quot;&quot;,[]};
es_1(ES=[{startElement,ParentNS1,ParentTag1,_,_}|Ancestors1],Event={startElement,_,_,_,_},State) -&gt;
    io:format(standard_error,&quot;Push start element onto stack~n&quot;,[]),
    {State#{element_stack =&gt; [Event | ES]},ParentNS1,ParentTag1,Ancestors1};
es_1([{startElement,NS,Tag,_,_}|Ancestors1],{endElement,NS,Tag,_,_},State) -&gt;
    {State#{element_stack =&gt; Ancestors1},NS,Tag,Ancestors1};    
es_1([{startElement,ParentNS1,ParentTag1,_,_}|_Ancestors1],{endElement,NS,Tag,_,_},_) -&gt;
    Msg = must_match({&quot;Opening tag namespace&quot;,ParentNS1},{&quot;closing tag namespace&quot;,NS}) ++
	must_match({&quot;End tag&quot;,Tag},{&quot;Opening tag&quot;,ParentTag1}),
    {error,Msg};
es_1([{startElement,ParentNS1,ParentTag1,_,_}|Ancestors1],_,State) -&gt;
    io:format(standard_error,&quot;No change to element stack option2~n&quot;,[]),
    {State,ParentNS1,ParentTag1,Ancestors1}.


do_evt_1({startElement,&quot;abc&quot;,&quot;file&quot;,_,AttrList},{S1,_,_,_}) -&gt;    
    Filename = attrvalue(&quot;filename&quot;,AttrList),
    {ok,OldFD} = maps:find(output,S1),
    S1#{output =&gt; set_output_file(Filename,OldFD)};
do_evt_1(OT2={startElement,&quot;abc&quot;,&quot;xml_tags&quot;,_,[]},{S1,_,_,_}) -&gt;    
    {ok,FinalOutput} = maps:find(final_output,S1),
    case FinalOutput of
	true -&gt;
	    S1#{escape_to_xml =&gt; true};
        false -&gt;
	    {ok,NSDecl2}=maps:find(prefix_next_tag,S1),
	    {ok,OldFD} = maps:find(output,S1),
	    write_open_tag(OT2,OldFD,NSDecl2),
	    S1
    end;
do_evt_1({startElement,&quot;http://www.w3.org/2001/XInclude&quot;,&quot;include&quot;,_,AttrList},{S1,_,_,_}) -&gt;    
    ?DEBUGSTR(&quot;xinclude start tag found&quot;),
    Filename = attrvalue(&quot;href&quot;,AttrList),
    Parse = attrvalue(&quot;parse&quot;,AttrList,&quot;xml&quot;),
    insert_file(Filename,Parse,S1),
    S1;
do_evt_1(OT=#startElement{},{S1,_,_,_}) -&gt;    
    ?DEBUGSTR(&quot;other start tag found&quot;),
    {ok,NSDecl}=maps:find(prefix_next_tag,S1),
    {ok,OldFD} = maps:find(output,S1),
    write_open_tag(OT,OldFD,NSDecl),
    S1#{prefix_next_tag =&gt; &quot;&quot;};
do_evt_1({endElement,&quot;http://www.w3.org/2001/XInclude&quot;,&quot;include&quot;,_},{S1,_,_,_}) -&gt;    
    S1;
do_evt_1( CT2={endElement,&quot;abc&quot;,&quot;xml_tags&quot;,_},{S1,_,_,_}) -&gt;    
    {ok,FinalOutput} = maps:find(final_output,S1),
    case FinalOutput of
	true -&gt; 
	    ok; 
	false -&gt;
	    {ok,OldFD} = maps:find(output,S1),
	    write_close_tag(CT2,OldFD)
    end,
    S1#{escape_to_xml =&gt; false};
do_evt_1({endElement,&quot;abc&quot;,&quot;file&quot;,_},{S1,_,_,_}) -&gt;    
    {ok,DefaultOutput} = maps:find(default_output,S1),
    {ok,OldFD} = maps:find(output,S1),
    S1#{output =&gt; set_output_file(DefaultOutput,OldFD)};
do_evt_1(CT = #endElement{} ,{S1,_,_,_}) -&gt;    
    {ok,ET} = maps:find(skip_end_tag,S1),
    case ET of
	true -&gt; 
	    S1#{skip_end_tag =&gt; false};
	false -&gt;
	    {ok,OldFD} = maps:find(output,S1),
	    write_close_tag(CT,OldFD),
 	    S1
    end;
do_evt_1({characters,Characters} ,{S1,_,_,_}) -&gt;    
    {ok,Esc} = maps:find(escape_to_xml,S1),
    {ok,FinalOutput} = maps:find(final_output,S1),
    {ok,OldFD} = maps:find(output,S1),
    OutputChars =
       case Esc and FinalOutput of
	   true -&gt;
	       reverse_escaping(Characters);
	   false -&gt;
	       xml_output_escaping(Characters)
       end,
    write_characters(OutputChars,OldFD),
    S1;
do_evt_1({processingInstruction,Type,Value} ,{S1,_,_,_}) -&gt;    
    {ok,OldFD} = maps:find(output,S1),
    io:fwrite(OldFD,&quot;~s&quot;,[&quot;&lt;?&quot;++Type++Value++&quot;?&gt;&quot;]),
    S1;
do_evt_1({startPrefixMapping,Prefix,Url} ,{S1,_,_,_}) -&gt;    
    {ok,PrefixNextTag} = maps:find(prefix_next_tag,S1),
    S1#{prefix_next_tag =&gt; [{Prefix,Url}|PrefixNextTag]};
do_evt_1({ignorableWhitespace,String} ,{S1,ParentNS,ParentTag,_}) -&gt;    
	    %% ignore whitespace after a xml_tags tag
	    {ok,P} = maps:find(preserve_whitespace,S1),
	    PreserveWhitespace = 
		    P and not
		       ((ParentTag ==&quot;file&quot;) and (ParentNS==&quot;abc&quot;)),
	    case PreserveWhitespace of
		true -&gt;
		    {ok,OldFD} = maps:find(output,S1),
		    write_characters(String,OldFD);
		false -&gt; 
		    ok
	    end,
    S1;
do_evt_1(_,{S1,_,_,_}) -&gt;    
    S1.


insert_file(Filename,[],S1) -&gt;
    insert_file_xml(Filename,S1);
insert_file(Filename,&quot;xml&quot;,S1) -&gt;
    insert_file_xml(Filename,S1);
insert_file(Filename,&quot;text&quot;,S1) -&gt;
    {ok,OldFD} = maps:find(output,S1),
    insert_file_text(Filename,OldFD).
    
must_match({_,X},{_,X}) -&gt;
    &quot;&quot;;
must_match({L1,V1},{L2,V2}) -&gt;
    io_lib:format(?MUST_MATCH,[L1,V1,L2,V2]).


attrvalue(AttName,AttrList) -&gt;
    attrvalue(AttName,AttrList,throw).

attrvalue(AttName,[],throw) -&gt;
    throw(&quot;Attribute &quot;++AttName++&quot; not found&quot;);
attrvalue(_,[],Default) -&gt;
    Default;
attrvalue(AttName,[#attribute{localName=AttName,value=Value}|_],_) -&gt;
    Value;
attrvalue(AttName,[_|T],Default) -&gt;
    attrvalue(AttName,T,Default).

-spec set_output_file(string()) -&gt; integer().
set_output_file(FileName) -&gt;
    ?DEBUGSTR(&quot;setting output directory to&quot;),
    ?DEBUG(FileName),
    ?DEBUGSTR(&quot;current directory is&quot;),
    ?DEBUG(filename:absname(&quot;.&quot;)),

    {ok,F}=file:open(FileName,[write]),
    F.

set_output_file(FileName,standard_io) -&gt;
    set_output_file(FileName);

set_output_file(FileName,OldFd) -&gt;
    ok=file:close(OldFd),
    {ok,F} = file:open(FileName,[write]),
    F.

insert_file_xml(Filename,State) -&gt;
    {ok,I} = maps:find(fileinclusions,State),
    State2 = case ordsets:is_element(Filename,I) of
	true -&gt;
	    throw(&quot;recursive xinclude on file &quot;++Filename);
	false -&gt;
	    State#{fileinclusions =&gt; ordsets:add_element(Filename,I)}
    end,
    Str =
	case file:read_file(Filename) of
	    {ok,Str2} -&gt; Str2;
	    {X,Y} -&gt; 
		io:format(standard_error,&quot;Could not read file ~s~n&quot;,[Filename]),
		throw({X,Y})
	end,
    erlsom:parse_sax(Str,State2,fun doevent/2).
    
-spec insert_file_text(string(), integer()) -&gt; ok.
insert_file_text(Filename,FD) -&gt; 
    Str1 =
	case file:read_file(Filename) of
	    {ok,Str} -&gt; Str;
	    {error,enoent} -&gt;
		throw (lists:flatten(io_lib:format(&quot;missing file ~s&quot;,[Filename])))
	end,
    Str2 = xml_output_escaping(binary_to_list(Str1)),
    io:fwrite(FD,&quot;~s&quot;,[&quot;&lt;pre&gt;&quot;]),
    io:fwrite(FD,&quot;~s&quot;,[Str2]),
    io:fwrite(FD,&quot;~s&quot;,[&quot;&lt;/pre&gt;&quot;]).

xml_parameter_formatting(X) -&gt;
    xml_output_escaping(lists:flatten(io_lib:write(X))).

xml_output_escaping(S) -&gt;
    [case X of 
	$&lt; -&gt; &quot;&amp;lt;&quot;; 
	$&quot; -&gt; &quot;&amp;quot;&quot;; 
	$&gt; -&gt; &quot;&amp;gt;&quot;; 
	$&apos; -&gt; &quot;&amp;apos;&quot;; 
	$&amp; -&gt; &quot;&amp;amp;&quot;; 
	_ -&gt; X 
    end 
    || X &lt;- S ].

reverse_escaping(S) -&gt;
    reverse_escaping(S,[]).

reverse_escaping([$&amp;|T],Q) -&gt;
    reverse_escape(T,[$&amp;],Q);
reverse_escaping([H|T],Q) -&gt;
    reverse_escaping(T,[H|Q]);
reverse_escaping([],Q) -&gt;
    lists:reverse(Q).

reverse_escape(S,&quot;&amp;lt;&quot;,Q) -&gt;
    reverse_escaping(S,[$&lt;|Q]);
reverse_escape(S,&quot;&amp;quot;&quot;,Q) -&gt;
    reverse_escaping(S,[$&quot;|Q]);
reverse_escape(S,&quot;&amp;gt;&quot;,Q) -&gt;
    reverse_escaping(S,[$&gt;|Q]);
reverse_escape(S,&quot;&amp;apos;&quot;,Q) -&gt;
    reverse_escaping(S,[$&apos;|Q]);
reverse_escape(S,&quot;&amp;amp;&quot;,Q) -&gt;
    reverse_escaping(S,[$&amp;|Q]);
reverse_escape([X|S],A,Q) when length(A) &lt; 6 -&gt;
    reverse_escape(S,A++[X],Q);
reverse_escape(_,Seq,_) -&gt;
    throw(&quot;Invalid escape sequence &quot;++Seq).

write_open_tag({startElement,_,Tag,&quot;&quot;,AttrList},FD,NSDecl) -&gt;
    ?DEBUGSTR(&quot;write_open_tag rule1&quot;),
    ?DEBUG(NSDecl),
    io:fwrite(FD,&quot;~s&quot;,[&quot;&lt;&quot;++Tag++&quot; &quot;]), 
    ok=write_name_decl(NSDecl,FD),
    write_attributes(AttrList,FD),
    io:fwrite(FD,&quot;~s&quot;,[&quot;&gt;&quot;]);

write_open_tag({startElement,_,Tag,Prefix,AttrList},FD,NSDecl) -&gt;
    ?DEBUGSTR(&quot;write_open_tag rule2&quot;),
    io:format(standard_error,&quot;write_open_tag ~n  Prefix=~s~n  Tag=~s~n  Attributes=~p~n  Namespaces=~p~n&quot;,[Prefix,Tag,AttrList,NSDecl]),
    io:fwrite(FD,&quot;~s&quot;,[&quot;&lt;&quot;++Prefix++&quot;:&quot;++Tag++&quot; &quot;]), 
    ok=write_name_decl(NSDecl,FD),
    write_attributes(AttrList,FD),
    io:fwrite(FD,&quot;~s&quot;,[&quot;&gt;&quot;]).

write_close_tag({endElement,_,LocalName,&quot;&quot;}, FD)-&gt;
   io:fwrite(FD,&quot;~s&quot;,[&quot;&lt;/&quot;++LocalName++&quot;&gt;&quot;]);

write_close_tag({endElement,_,LocalName,Prefix},FD) -&gt;
    io:fwrite(FD,&quot;~s&quot;,[&quot;&lt;/&quot;++Prefix++&quot;:&quot;++LocalName++&quot;&gt;&quot;]).

write_name_decl([],_) -&gt;
    ok;
write_name_decl([{&quot;&quot;,Url}|T],FD) -&gt; 
    NS = &quot; xmlns=\&quot;&quot;++Url++&quot;\&quot;&quot;,
    io:format(standard_error,&quot;write_name_decl (no prefix) url=~s~n&quot;,[Url]),
    io:fwrite(FD,&quot;~s&quot;,[NS]),
    write_name_decl(T,FD);
    
write_name_decl([{Prefix,Url}|T],FD) -&gt;
    NS = &quot; xmlns:&quot;++Prefix++&quot;=\&quot;&quot;++Url++&quot;\&quot;&quot;,
    ?DEBUG(NS),
    io:format(standard_error,&quot;write_name_decl prefix=~s url=~s~n&quot;,[Prefix,Url]),
    io:fwrite(FD,&quot;~s&quot;,[NS]),
    write_name_decl(T,FD).

write_attributes([],_) -&gt;  ok;
write_attributes([{attribute,LocalName,_Uri,Prefix,Value}|T],FD) -&gt;
    io:fwrite(FD,&quot;~s&quot;,[&quot; &quot;++Prefix++LocalName++&quot;=\&quot;&quot;++Value++&quot;\&quot;&quot;]),
    write_attributes(T,FD).

write_characters(String,FD) -&gt;
    io:fwrite(FD,&quot;~s&quot;,[String]).


do_test(&quot;test&quot;) -&gt;
    test();
do_test(&quot;test1&quot;) -&gt;
    test1();
do_test(&quot;test2&quot;) -&gt;
    test2();
do_test(&quot;test3&quot;) -&gt;
    test3();
do_test(&quot;test4&quot;) -&gt;
    test4();
do_test(&quot;test5&quot;) -&gt;
    test5();
do_test(&quot;test6&quot;) -&gt;
    test6();
do_test(&quot;test7&quot;) -&gt;
    test7();
do_test(&quot;test8&quot;) -&gt;
    test8();
do_test(&quot;test9&quot;) -&gt;
    test9();
do_test(&quot;test10&quot;) -&gt;
    test10();
do_test(X) -&gt;
    throw(&quot;unknown test &quot;++X).

test_cmd() -&gt;
    %&quot;escript ebin/xslt_extn.beam &quot;.
    &quot;./escript &quot;.


test() -&gt;
    io:format(&quot;testing started, current directory is ~n~s~n&quot;,[filename:absname(&quot;.&quot;)]),
    test1(),
    test2(),
    test3(),
    test4(),
    test5(),
    test6(),
   % test7(),
    test8(),
    test9(),
    test10(),
    ok.

test1() -&gt;
    Testid = &quot;test1&quot;,
    InputFile = &quot;test/input/test1.xml&quot;,
    OutputFile = filename:join([&quot;test/output&quot;,Testid])++&quot;.xml&quot;,
    ErrorFile = filename:join([&quot;test/output&quot;,Testid])++&quot;.err.txt&quot;,
    Options = &quot;&quot;,
    io:format(standard_error,&quot;~s~n&quot;,[Testid]),
    Cmd = test_cmd()++ Options ++&quot; &lt; &quot; 
	++ InputFile ++ &quot; &gt; &quot; ++ OutputFile
	++ &quot; 2&gt; &quot; ++ ErrorFile,
    ?DEBUG(Cmd),
    os:cmd(Cmd),
    ok.

test2() -&gt;
    Testid = &quot;test2&quot;,
    InputFile = &quot;test/input/testinclusion.xml&quot;,
    OutputFile = filename:join([&quot;test/output&quot;,Testid])++&quot;.xml&quot;,
    ErrorFile = filename:join([&quot;test/output&quot;,Testid])++&quot;.err.txt&quot;,
    Options = &quot;&quot;,
    io:format(standard_error,&quot;~s~n&quot;,[Testid]),
    Cmd = test_cmd()++ Options ++&quot; &lt; &quot; 
	++ InputFile ++ &quot; &gt; &quot; ++ OutputFile
	++ &quot; 2&gt; &quot; ++ ErrorFile,
    ?DEBUG(Cmd),
    os:cmd(Cmd),
    ok.
    
test3() -&gt;
    Testid = &quot;test3&quot;,
    InputFile = &quot;test/input/testinclusion2.xml&quot;,
    OutputFile = filename:join([&quot;test/output&quot;,Testid])++&quot;.xml&quot;,
    ErrorFile = filename:join([&quot;test/output&quot;,Testid])++&quot;.err.txt&quot;,
    Options = &quot;&quot;,
    io:format(standard_error,&quot;~s~n&quot;,[Testid]),
    Cmd = test_cmd()++ Options ++&quot; &lt; &quot; 
	++ InputFile ++ &quot; &gt; &quot; ++ OutputFile
	++ &quot; 2&gt; &quot; ++ ErrorFile,
    ?DEBUG(Cmd),
    os:cmd(Cmd),
    ok.
    
test4() -&gt;
    Testid = &quot;test4&quot;,
    InputFile = &quot;test/input/testinclusion3.xml&quot;,
    OutputFile = filename:join([&quot;test/output&quot;,Testid])++&quot;.xml&quot;,
    ErrorFile = filename:join([&quot;test/output&quot;,Testid])++&quot;.err.txt&quot;,
    Options = &quot;&quot;,
    io:format(standard_error,&quot;~s~n&quot;,[Testid]),
    Cmd = test_cmd()++ Options ++&quot; &lt; &quot; 
	++ InputFile ++ &quot; &gt; &quot; ++ OutputFile
	++ &quot; 2&gt; &quot; ++ ErrorFile,
    ?DEBUG(Cmd),
    os:cmd(Cmd),
    ok.
    
test5() -&gt;
    io:format(&quot;test5~n&quot;),
    InputFile = &quot;test/input/test_file_output.xml&quot;,
    OutputFile = &quot;test/output/test5.xml&quot;,
    ErrorFile = &quot;test/output/test5.err.txt&quot;,
    Options = &quot;+finaloutput&quot;,
    Cmd = test_cmd()++ Options ++&quot; &lt; &quot; 
	++ InputFile ++ &quot; &gt; &quot; ++ OutputFile
	++ &quot; 2&gt; &quot; ++ ErrorFile,
    ?DEBUG(Cmd),
    os:cmd(Cmd),
    ok.

test6() -&gt;
    Testid = &quot;test6&quot;,
    OutputFile = filename:join([&quot;test/output&quot;,Testid])++&quot;.xml&quot;,
    io:format(standard_error,&quot;~s~n&quot;,[Testid]),
    Fd = set_output_file(OutputFile),
    {ok,Str} = file:read_file(&quot;test/input/test_namespaces.xml&quot;),
    S0 = default_state(),
    parseStr(Str,S0#{output =&gt; Fd}),
    ok.

test7() -&gt;    
    Testid = &quot;test7&quot;,
    io:format(standard_error,&quot;~s~n&quot;,[Testid]),
    %% Test recursive xml include
    InputFile = &quot;test/input/recursive_include_xml.xml&quot;,
    OutputFile = &quot;test/output/test7.xml&quot;,
    ErrorFile = &quot;test/output/test7.err.txt&quot;,
    Options = &quot;&quot;,
    Cmd = test_cmd()++ Options ++&quot; &lt; &quot; 
	++ InputFile ++ &quot; &gt; &quot; ++ OutputFile
	++ &quot; 2&gt; &quot; ++ ErrorFile,
    os:cmd(Cmd).

test8() -&gt;
    Testid = &quot;test8&quot;,
    io:format(standard_error,&quot;~s~n&quot;,[Testid]),
    %% test reverse escaping
    &quot;&lt;tag&gt;&quot; = reverse_escaping(&quot;&amp;lt;tag&amp;gt;&quot;),
    &quot;a&lt;tag&gt;b&quot; = reverse_escaping(&quot;a&amp;lt;tag&amp;gt;b&quot;),
    &quot;\&quot;hi\&apos;&quot; = reverse_escaping(&quot;&amp;quot;hi&amp;apos;&quot;),
    &quot;&amp;&quot; = reverse_escaping(&quot;&amp;amp;&quot;),
    ok.

test9() -&gt;
    Testid = &quot;test9&quot;,
    io:format(standard_error,&quot;~s~n&quot;,[Testid]),
    %% test xml_tags  +finaloutput (default)
    %% expect validly formed xml output
    %% expect tags in escaped format
    %% test reverse escaping in final output
    InputFile = &quot;test/input/xml_tags_tag.xml&quot;,
    OutputFile = &quot;test/output/test9.xml&quot;,
    ErrorFile = &quot;test/output/error9.txt&quot;,
    Options = &quot;+finaloutput&quot;,
    %% test relative directories okay
    true = filelib:is_dir(&quot;test/input&quot;),
    true = filelib:is_dir(&quot;test/output&quot;),
    %% generate test data
    Data = [&quot;&lt;root xmlns:q=\&quot;abc\&quot;&gt;&quot;,
	     &quot;&lt;q:xml_tags&gt;&amp;lt;tag/&amp;gt;&lt;/q:xml_tags&gt;&quot;,
	     &quot;&lt;/root&gt;&quot;],
    file:write_file(InputFile,
		    Data),
    %% run test
    ?DEBUGSTR(&quot;Test9 running test&quot;),
    Cmd = test_cmd()++Options++&quot; &lt; &quot; 
	++ InputFile ++ &quot; &gt; &quot; ++ OutputFile
	++ &quot; 2&gt; &quot; ++ ErrorFile,
    ?DEBUG(Cmd),
    os:cmd(Cmd),
    %% check result

    case filelib:is_regular(OutputFile) of
	true -&gt;
	    {ok,R} = file:read_file(OutputFile),
	    io:format(&quot;~s~n&quot;,[R]);
	false -&gt;
	    throw(&quot;test 9 did not generate an output file&quot;)
    end.

test10() -&gt;
    Testid = &quot;test10&quot;,
    io:format(standard_error,&quot;~s~n&quot;,[Testid]),
    %% test xml_tags not final output (default)
    %% expect validly formed xml output
    %% expect tags in escaped format
    InputFile = &quot;test/input/xml_tags_tag.xml&quot;,
    OutputFile = &quot;test/output/test10.xml&quot;,
    ErrorFile = &quot;test/output/error10.txt&quot;,
    Options = &quot;&quot;,
    %% test relative directories okay
    true = filelib:is_dir(&quot;test/input&quot;),
    true = filelib:is_dir(&quot;test/output&quot;),
    %% generate test data
    Data = [&quot;&lt;root xmlns:q=\&quot;abc\&quot;&gt;&quot;,
	     &quot;&lt;q:xml_tags&gt;&amp;lt;tag/&amp;gt;&lt;/q:xml_tags&gt;&quot;,
	     &quot;&lt;/root&gt;&quot;],
    file:write_file(InputFile,
		    Data),
    %% run test
    ?DEBUGSTR(&quot;Test10 running test&quot;),
    Cmd = test_cmd()++Options++&quot;&lt; &quot; 
	++ InputFile ++ &quot; &gt; &quot; ++ OutputFile
	++ &quot; 2&gt; &quot; ++ ErrorFile,
    ?DEBUG(Cmd),
    os:cmd(Cmd),
    %% check result

    case filelib:is_regular(OutputFile) of
	true -&gt;
	    {ok,R} = file:read_file(OutputFile),
	    io:format(&quot;~s~n&quot;,[R]);
	false -&gt;
	    throw(&quot;test 10 did not generate an output file&quot;)
    end.
    
</pre>
</xhtml:pre><xhtml:h2  xmlns:xf="http://www.w3.org/2002/xforms" xmlns:xi="http://www.w3.org/2001/XInclude">A build script to put it all together</xhtml:h2><xhtml:pre  xmlns:xf="http://www.w3.org/2002/xforms" xmlns:xi="http://www.w3.org/2001/XInclude">

cd site_data
escript ../ebin/xslt_extn.beam &lt; pagedata.xml &gt; fullsite.xml 2&gt; errors.txt
xsltproc ../src/make_web2.xsl fullsite.xml &gt; allpages.xml
escript ../ebin/xslt_extn.beam +finaloutput &lt; allpages.xml 
mv *.html ../html

</xhtml:pre><xhtml:p  xmlns:xf="http://www.w3.org/2002/xforms" xmlns:xi="http://www.w3.org/2001/XInclude">The first call to xslt_extn includes all the page
definitions in pagedata.xml creating the file fillsite.xml.
This data is then put through xslt processing to form a
new file allpages.xml.  This file has all the webpages
properly laid out, but all in a single file.  xslt_extn
is called again to split these files and output the
processing instructions into the web pages.  Finally
these html web pages are copied to the websites html directory.
</xhtml:p></xhtml:section></xhtml:body></xhtml:html>